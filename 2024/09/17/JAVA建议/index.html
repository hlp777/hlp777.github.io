<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个简单的博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>JAVA建议 |  huang</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JAVA建议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JAVA建议
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/09/17/JAVA%E5%BB%BA%E8%AE%AE/" class="article-date">
  <time datetime="2024-09-17T03:53:59.000Z" itemprop="datePublished">2024-09-17</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">12 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-考虑用静态工厂方法代替构造函数"><a href="#1-考虑用静态工厂方法代替构造函数" class="headerlink" title="1.考虑用静态工厂方法代替构造函数"></a>1.考虑用静态工厂方法代替构造函数</h4><p><strong>静态工厂方法的好处</strong></p>
<p><strong>1.与构造函数不同,静态工厂方法具有名字</strong></p>
<p><strong>2.与构造函数不同，它们每次被调用的时候，不要求非得创建一个新的对象</strong></p>
<p><strong>3.与构造函数不同，它可以返回一个原返回类型的子类型的对象</strong></p>
<p><strong>缺点</strong></p>
<h5 id="主要：类如果不含公有的或者受保护的构造函数，就不能被子类化"><a href="#主要：类如果不含公有的或者受保护的构造函数，就不能被子类化" class="headerlink" title="主要：类如果不含公有的或者受保护的构造函数，就不能被子类化"></a>主要：类如果不含公有的或者受保护的构造函数，就不能被子类化</h5><p><strong>2.它们与其他的静态方法没有任何区别</strong></p>
<h4 id="2-使用私有构造函数强化singleton属性"><a href="#2-使用私有构造函数强化singleton属性" class="headerlink" title="2.使用私有构造函数强化singleton属性"></a>2.使用私有构造函数强化singleton属性</h4><h4 id="3-通过私有构造函数强化不可实例化的能力"><a href="#3-通过私有构造函数强化不可实例化的能力" class="headerlink" title="3.通过私有构造函数强化不可实例化的能力"></a>3.通过私有构造函数强化不可实例化的能力</h4><h4 id="4-避免创建重复的对象"><a href="#4-避免创建重复的对象" class="headerlink" title="4.避免创建重复的对象"></a>4.避免创建重复的对象</h4><h4 id="5-消除过期的对象引用"><a href="#5-消除过期的对象引用" class="headerlink" title="5.消除过期的对象引用"></a>5.消除过期的对象引用</h4><h4 id="6-避免使用终结函数"><a href="#6-避免使用终结函数" class="headerlink" title="6.避免使用终结函数"></a>6.避免使用终结函数</h4><h4 id="7-在改写equals的时候请遵守通用约定"><a href="#7-在改写equals的时候请遵守通用约定" class="headerlink" title="7.在改写equals的时候请遵守通用约定"></a>7.在改写equals的时候请遵守通用约定</h4><h4 id="8-在改写equals时总是要改写hashCods"><a href="#8-在改写equals时总是要改写hashCods" class="headerlink" title="8.在改写equals时总是要改写hashCods"></a>8.在改写equals时总是要改写hashCods</h4><h4 id="9-总是要改写toString"><a href="#9-总是要改写toString" class="headerlink" title="9.总是要改写toString"></a>9.总是要改写toString</h4><h4 id="10-谨慎改写clone"><a href="#10-谨慎改写clone" class="headerlink" title="10.谨慎改写clone"></a>10.谨慎改写clone</h4><h4 id="11-考虑实现Comparable接口"><a href="#11-考虑实现Comparable接口" class="headerlink" title="11.考虑实现Comparable接口"></a>11.考虑实现Comparable接口</h4><h4 id="12-使类和成员的可访问能力最小化"><a href="#12-使类和成员的可访问能力最小化" class="headerlink" title="12.使类和成员的可访问能力最小化"></a>12.使类和成员的可访问能力最小化</h4><p><strong>尽可能使每一个类或成员不被外界访问</strong></p>
<h4 id="13-支持非可变性"><a href="#13-支持非可变性" class="headerlink" title="13.支持非可变性"></a>13.支持非可变性</h4><h5 id="1-不要提供任何会修改对象的方法（也称为mutator）"><a href="#1-不要提供任何会修改对象的方法（也称为mutator）" class="headerlink" title="1.不要提供任何会修改对象的方法（也称为mutator）"></a>1.不要提供任何会修改对象的方法（也称为mutator）</h5><h5 id="2-保证没有可被子类改写的方法"><a href="#2-保证没有可被子类改写的方法" class="headerlink" title="2.保证没有可被子类改写的方法"></a>2.保证没有可被子类改写的方法</h5><h5 id="3-使所有的域都是final的"><a href="#3-使所有的域都是final的" class="headerlink" title="3.使所有的域都是final的"></a>3.使所有的域都是final的</h5><h5 id="4-使所有域都是成为私有的"><a href="#4-使所有域都是成为私有的" class="headerlink" title="4.使所有域都是成为私有的"></a>4.使所有域都是成为私有的</h5><h5 id="5-保证对于任何可变组件的互斥访问"><a href="#5-保证对于任何可变组件的互斥访问" class="headerlink" title="5.保证对于任何可变组件的互斥访问"></a>5.保证对于任何可变组件的互斥访问</h5><h4 id="14-复合优先于继承"><a href="#14-复合优先于继承" class="headerlink" title="14.复合优先于继承"></a>14.复合优先于继承</h4><h4 id="15-要么专门为继承而设计，并给出文档说明，要么禁止继承"><a href="#15-要么专门为继承而设计，并给出文档说明，要么禁止继承" class="headerlink" title="15.要么专门为继承而设计，并给出文档说明，要么禁止继承"></a>15.要么专门为继承而设计，并给出文档说明，要么禁止继承</h4><p><strong>一个类必须通过某种形式提供适合的钩子，以便能够进入到它的内部工作流程中，这样的形式可以是精心选择的受保护（protected）方法</strong></p>
<p><strong>构造函数一定不能调用可被改写的方法</strong></p>
<p><strong>无论是clone还是readObject，都不能调用一个可改写的方法，不管是直接的方式，还是间接的方式</strong></p>
<p><strong>为了继承设计一个类，要求对这个类有一些实质性的限制</strong></p>
<p><strong>对于那些并非为了安全地进行子类化而设计和编写文档类，禁止子类化</strong></p>
<h5 id="禁止子类化的两种方法"><a href="#禁止子类化的两种方法" class="headerlink" title="禁止子类化的两种方法"></a>禁止子类化的两种方法</h5><p><strong>1.直接把这个类声明为final的</strong></p>
<p><strong>2.把所有的构造函数变成私有的，或者包级私有的，并且增加一些公有的静态工厂来替代构造函数的位置</strong></p>
<h4 id="16接口优于抽象类"><a href="#16接口优于抽象类" class="headerlink" title="16接口优于抽象类"></a>16接口优于抽象类</h4><p><strong>接口和抽象类最大的区别是：抽象类允许包含某些方法的实现，但是接口是不允许的</strong></p>
<h5 id="已有的类可以很容易被更新，已实现新的接口"><a href="#已有的类可以很容易被更新，已实现新的接口" class="headerlink" title="已有的类可以很容易被更新，已实现新的接口"></a>已有的类可以很容易被更新，已实现新的接口</h5><h5 id="接口是定义mixin（混合类型）的理想选择"><a href="#接口是定义mixin（混合类型）的理想选择" class="headerlink" title="接口是定义mixin（混合类型）的理想选择"></a>接口是定义mixin（混合类型）的理想选择</h5><h5 id="接口使得我们可以构造出非层次结构的类型框架"><a href="#接口使得我们可以构造出非层次结构的类型框架" class="headerlink" title="接口使得我们可以构造出非层次结构的类型框架"></a>接口使得我们可以构造出非层次结构的类型框架</h5><h5 id="接口使得安全地增强一个类的功能成为可能"><a href="#接口使得安全地增强一个类的功能成为可能" class="headerlink" title="接口使得安全地增强一个类的功能成为可能"></a>接口使得安全地增强一个类的功能成为可能</h5><p><strong>你可以把接口和抽象类的优点结合起来，对于你期望导出的每一个重要接口，都提供一个抽象的骨架实现（skeletal implementation）类</strong></p>
<h5 id="抽象类的演化比接口的演化要容易得多"><a href="#抽象类的演化比接口的演化要容易得多" class="headerlink" title="抽象类的演化比接口的演化要容易得多"></a>抽象类的演化比接口的演化要容易得多</h5><h4 id="17-接口只是被用于定义类型"><a href="#17-接口只是被用于定义类型" class="headerlink" title="17.接口只是被用于定义类型"></a>17.接口只是被用于定义类型</h4><p><strong>常量接口模式是对接口的不良使用</strong></p>
<h4 id="18-优先考虑静态成员类"><a href="#18-优先考虑静态成员类" class="headerlink" title="18.优先考虑静态成员类"></a>18.优先考虑静态成员类</h4><p><strong>如果你声明的成员类不要求访问外围实例，那么请记住把static修饰符放到成员类的声明中</strong></p>
<h4 id="19-用类代替结构"><a href="#19-用类代替结构" class="headerlink" title="19.用类代替结构"></a>19.用类代替结构</h4><h4 id="20-用类层次来代替联合"><a href="#20-用类层次来代替联合" class="headerlink" title="20.用类层次来代替联合"></a>20.用类层次来代替联合</h4><h4 id="21-用类来代替enum结构"><a href="#21-用类来代替enum结构" class="headerlink" title="21.用类来代替enum结构"></a>21.用类来代替enum结构</h4><h4 id="22-用类和接口来代替函数指针"><a href="#22-用类和接口来代替函数指针" class="headerlink" title="22.用类和接口来代替函数指针"></a>22.用类和接口来代替函数指针</h4><h4 id="23-检查参数的有效性"><a href="#23-检查参数的有效性" class="headerlink" title="23.检查参数的有效性"></a>23.检查参数的有效性</h4><h4 id="24-需要时使用保护性拷贝"><a href="#24-需要时使用保护性拷贝" class="headerlink" title="24.需要时使用保护性拷贝"></a>24.需要时使用保护性拷贝</h4><h5 id="假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序"><a href="#假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序" class="headerlink" title="假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序"></a>假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序</h5><h5 id="对于构造函数的每个可变参数进行保护性拷贝（defensive-copy）是必要的"><a href="#对于构造函数的每个可变参数进行保护性拷贝（defensive-copy）是必要的" class="headerlink" title="对于构造函数的每个可变参数进行保护性拷贝（defensive copy）是必要的"></a>对于构造函数的每个可变参数进行保护性拷贝（defensive copy）是必要的</h5><h5 id="保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象"><a href="#保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象" class="headerlink" title="保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象"></a>保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象</h5><h5 id="对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝"><a href="#对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝" class="headerlink" title="对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝"></a>对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝</h5><h4 id="25-谨慎设计方法的原型"><a href="#25-谨慎设计方法的原型" class="headerlink" title="25.谨慎设计方法的原型"></a>25.谨慎设计方法的原型</h4><h5 id="谨慎选择方法的名字"><a href="#谨慎选择方法的名字" class="headerlink" title="谨慎选择方法的名字"></a>谨慎选择方法的名字</h5><h5 id="不要过于追求提供便利的方法"><a href="#不要过于追求提供便利的方法" class="headerlink" title="不要过于追求提供便利的方法"></a>不要过于追求提供便利的方法</h5><h5 id="避免长长的参数列表"><a href="#避免长长的参数列表" class="headerlink" title="避免长长的参数列表"></a>避免长长的参数列表</h5><h5 id="对于参数类型，优先使用接口而不是类"><a href="#对于参数类型，优先使用接口而不是类" class="headerlink" title="对于参数类型，优先使用接口而不是类"></a>对于参数类型，优先使用接口而不是类</h5><h5 id="谨慎地使用函数对象"><a href="#谨慎地使用函数对象" class="headerlink" title="谨慎地使用函数对象"></a>谨慎地使用函数对象</h5><h4 id="26-谨慎地使用重载"><a href="#26-谨慎地使用重载" class="headerlink" title="26.谨慎地使用重载"></a>26.谨慎地使用重载</h4><h5 id="对于重载该方法（overloaded-method）的选择是静态的，而对于被改写的方法（overridden-method）的选择是动态的"><a href="#对于重载该方法（overloaded-method）的选择是静态的，而对于被改写的方法（overridden-method）的选择是动态的" class="headerlink" title="对于重载该方法（overloaded method）的选择是静态的，而对于被改写的方法（overridden method）的选择是动态的"></a>对于重载该方法（overloaded method）的选择是静态的，而对于被改写的方法（overridden method）的选择是动态的</h5><h5 id="避免方法重载机制的混淆用法"><a href="#避免方法重载机制的混淆用法" class="headerlink" title="避免方法重载机制的混淆用法"></a>避免方法重载机制的混淆用法</h5><h5 id="一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法"><a href="#一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法" class="headerlink" title="一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法"></a>一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法</h5><h4 id="27-返回零长度的数组而不是null"><a href="#27-返回零长度的数组而不是null" class="headerlink" title="27.返回零长度的数组而不是null"></a>27.返回零长度的数组而不是null</h4><h5 id="没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组"><a href="#没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组" class="headerlink" title="没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组"></a>没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组</h5><h4 id="28-为所有导出的API元素编写文档注释"><a href="#28-为所有导出的API元素编写文档注释" class="headerlink" title="28.为所有导出的API元素编写文档注释"></a>28.为所有导出的API元素编写文档注释</h4><h5 id="为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释"><a href="#为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释" class="headerlink" title="为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释"></a>为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释</h5><h5 id="每一个方法的文档注释应该简洁地描述出它和客户之间的约定"><a href="#每一个方法的文档注释应该简洁地描述出它和客户之间的约定" class="headerlink" title="每一个方法的文档注释应该简洁地描述出它和客户之间的约定"></a>每一个方法的文档注释应该简洁地描述出它和客户之间的约定</h5><h4 id="29-将局部变量的作用域最小化"><a href="#29-将局部变量的作用域最小化" class="headerlink" title="29.将局部变量的作用域最小化"></a>29.将局部变量的作用域最小化</h4><h5 id="使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明"><a href="#使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明" class="headerlink" title="使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明"></a>使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明</h5><h5 id="几乎每一个局部变量的声明都应该包含一个初始化表达式"><a href="#几乎每一个局部变量的声明都应该包含一个初始化表达式" class="headerlink" title="几乎每一个局部变量的声明都应该包含一个初始化表达式"></a>几乎每一个局部变量的声明都应该包含一个初始化表达式</h5><h4 id="30-了解和使用库"><a href="#30-了解和使用库" class="headerlink" title="30.了解和使用库"></a>30.了解和使用库</h4><h5 id="通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验"><a href="#通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验" class="headerlink" title="通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验"></a>通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验</h5><h5 id="在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的"><a href="#在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的" class="headerlink" title="在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的"></a>在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的</h5><h4 id="31-如果要求精确的答案，请避免使用float和double"><a href="#31-如果要求精确的答案，请避免使用float和double" class="headerlink" title="31.如果要求精确的答案，请避免使用float和double"></a>31.如果要求精确的答案，请避免使用float和double</h4><h4 id="32-如果其他类型更合适，则尽量避免使用字符串"><a href="#32-如果其他类型更合适，则尽量避免使用字符串" class="headerlink" title="32.如果其他类型更合适，则尽量避免使用字符串"></a>32.如果其他类型更合适，则尽量避免使用字符串</h4><h5 id="字符串不适合代替其他的值类型"><a href="#字符串不适合代替其他的值类型" class="headerlink" title="字符串不适合代替其他的值类型"></a>字符串不适合代替其他的值类型</h5><h5 id="字符串不适合代替枚举类型"><a href="#字符串不适合代替枚举类型" class="headerlink" title="字符串不适合代替枚举类型"></a>字符串不适合代替枚举类型</h5><h5 id="字符串不适合代替聚集类型"><a href="#字符串不适合代替聚集类型" class="headerlink" title="字符串不适合代替聚集类型"></a>字符串不适合代替聚集类型</h5><h5 id="字符串也不适合代替能力表"><a href="#字符串也不适合代替能力表" class="headerlink" title="字符串也不适合代替能力表"></a>字符串也不适合代替能力表</h5><h4 id="33-了解字符串连接的性能"><a href="#33-了解字符串连接的性能" class="headerlink" title="33.了解字符串连接的性能"></a>33.了解字符串连接的性能</h4><h5 id="为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间"><a href="#为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间" class="headerlink" title="为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间"></a>为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间</h5><h5 id="为了获得可接受的性能，请使用StringBuffer替代String"><a href="#为了获得可接受的性能，请使用StringBuffer替代String" class="headerlink" title="为了获得可接受的性能，请使用StringBuffer替代String"></a>为了获得可接受的性能，请使用StringBuffer替代String</h5><h4 id="34-通过接口引用对象"><a href="#34-通过接口引用对象" class="headerlink" title="34.通过接口引用对象"></a>34.通过接口引用对象</h4><h5 id="如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活"><a href="#如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活" class="headerlink" title="如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活"></a>如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活</h5><h5 id="如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的"><a href="#如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的" class="headerlink" title="如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的"></a>如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的</h5><h4 id="35-接口优先于映像机制"><a href="#35-接口优先于映像机制" class="headerlink" title="35.接口优先于映像机制"></a>35.接口优先于映像机制</h4><h5 id="映像机制的代价"><a href="#映像机制的代价" class="headerlink" title="映像机制的代价"></a>映像机制的代价</h5><h5 id="损失了编译时类型检查的好处"><a href="#损失了编译时类型检查的好处" class="headerlink" title="损失了编译时类型检查的好处"></a>损失了编译时类型检查的好处</h5><h5 id="要求执行映像访问的代码非常笨拙和冗长"><a href="#要求执行映像访问的代码非常笨拙和冗长" class="headerlink" title="要求执行映像访问的代码非常笨拙和冗长"></a>要求执行映像访问的代码非常笨拙和冗长</h5><h5 id="性能损失"><a href="#性能损失" class="headerlink" title="性能损失"></a>性能损失</h5><h5 id="通常，普通应用在运行时刻不应该以映像方式访问对象"><a href="#通常，普通应用在运行时刻不应该以映像方式访问对象" class="headerlink" title="通常，普通应用在运行时刻不应该以映像方式访问对象"></a>通常，普通应用在运行时刻不应该以映像方式访问对象</h5><h5 id="如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处"><a href="#如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处" class="headerlink" title="如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处"></a>如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处</h5><h4 id="36-谨慎地使用本地方法"><a href="#36-谨慎地使用本地方法" class="headerlink" title="36.谨慎地使用本地方法"></a>36.谨慎地使用本地方法</h4><h4 id="37-谨慎地进行优化"><a href="#37-谨慎地进行优化" class="headerlink" title="37.谨慎地进行优化"></a>37.谨慎地进行优化</h4><h5 id="努力避免那些限制性能的设计决定"><a href="#努力避免那些限制性能的设计决定" class="headerlink" title="努力避免那些限制性能的设计决定"></a>努力避免那些限制性能的设计决定</h5><h5 id="考虑你的API设计决定的性能后果"><a href="#考虑你的API设计决定的性能后果" class="headerlink" title="考虑你的API设计决定的性能后果"></a>考虑你的API设计决定的性能后果</h5><h5 id="为了获得好的性能而对API进行曲改，这是一个非常不好的想法"><a href="#为了获得好的性能而对API进行曲改，这是一个非常不好的想法" class="headerlink" title="为了获得好的性能而对API进行曲改，这是一个非常不好的想法"></a>为了获得好的性能而对API进行曲改，这是一个非常不好的想法</h5><h5 id="在每次试图做优化之前和之后，请对性能进行测量"><a href="#在每次试图做优化之前和之后，请对性能进行测量" class="headerlink" title="在每次试图做优化之前和之后，请对性能进行测量"></a>在每次试图做优化之前和之后，请对性能进行测量</h5><h4 id="39-只针对不正常的条件才使用异常"><a href="#39-只针对不正常的条件才使用异常" class="headerlink" title="39.只针对不正常的条件才使用异常"></a>39.只针对不正常的条件才使用异常</h4><h4 id="38-遵守普遍接受的命名惯例"><a href="#38-遵守普遍接受的命名惯例" class="headerlink" title="38.遵守普遍接受的命名惯例"></a>38.遵守普遍接受的命名惯例</h4><h5 id="异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流"><a href="#异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流" class="headerlink" title="异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流"></a>异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流</h5><h5 id="一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常"><a href="#一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常" class="headerlink" title="一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常"></a>一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常</h5><h4 id="40-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"><a href="#40-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常" class="headerlink" title="40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"></a>40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常</h4><h5 id="如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常"><a href="#如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常" class="headerlink" title="如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常"></a>如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常</h5><h5 id="用运行时异常来指明程序错误"><a href="#用运行时异常来指明程序错误" class="headerlink" title="用运行时异常来指明程序错误"></a>用运行时异常来指明程序错误</h5><h5 id="你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）"><a href="#你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）" class="headerlink" title="你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）"></a>你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）</h5><h4 id="41-避免不必要地使用被检查的异常"><a href="#41-避免不必要地使用被检查的异常" class="headerlink" title="41.避免不必要地使用被检查的异常"></a>41.避免不必要地使用被检查的异常</h4><h4 id="42-尽量使用标准的异常"><a href="#42-尽量使用标准的异常" class="headerlink" title="42.尽量使用标准的异常"></a>42.尽量使用标准的异常</h4><h4 id="43-抛出的异常要适合于相应的抽象"><a href="#43-抛出的异常要适合于相应的抽象" class="headerlink" title="43.抛出的异常要适合于相应的抽象"></a>43.抛出的异常要适合于相应的抽象</h4><h5 id="高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常"><a href="#高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常" class="headerlink" title="高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常"></a>高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常</h5><h5 id="尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用"><a href="#尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用" class="headerlink" title="尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用"></a>尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用</h5><h4 id="44-每个方法抛出的异常都要有文档"><a href="#44-每个方法抛出的异常都要有文档" class="headerlink" title="44.每个方法抛出的异常都要有文档"></a>44.每个方法抛出的异常都要有文档</h4><h5 id="总是要单独地声明被检查的异常，并且利用Javadoc的-throws标记，标准地记录下每个异常被抛出的条件"><a href="#总是要单独地声明被检查的异常，并且利用Javadoc的-throws标记，标准地记录下每个异常被抛出的条件" class="headerlink" title="总是要单独地声明被检查的异常，并且利用Javadoc的@throws标记，标准地记录下每个异常被抛出的条件"></a>总是要单独地声明被检查的异常，并且利用Javadoc的@throws标记，标准地记录下每个异常被抛出的条件</h5><h5 id="使用Javadoc的-throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中"><a href="#使用Javadoc的-throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中" class="headerlink" title="使用Javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中"></a>使用Javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中</h5><h5 id="如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的"><a href="#如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的" class="headerlink" title="如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的"></a>如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的</h5><h4 id="45-在细节消息中包含失败-捕获消息"><a href="#45-在细节消息中包含失败-捕获消息" class="headerlink" title="45.在细节消息中包含失败-捕获消息"></a>45.在细节消息中包含失败-捕获消息</h4><h5 id="为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值"><a href="#为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值" class="headerlink" title="为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值"></a>为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值</h5><h4 id="46-努力使失败保持原子性"><a href="#46-努力使失败保持原子性" class="headerlink" title="46.努力使失败保持原子性"></a>46.努力使失败保持原子性</h4><h5 id="一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”"><a href="#一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”" class="headerlink" title="一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”"></a>一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”</h5><h4 id="47-不要忽略异常"><a href="#47-不要忽略异常" class="headerlink" title="47.不要忽略异常"></a>47.不要忽略异常</h4><h5 id="空的catch块会使异常达不到应有的目的"><a href="#空的catch块会使异常达不到应有的目的" class="headerlink" title="空的catch块会使异常达不到应有的目的"></a>空的catch块会使异常达不到应有的目的</h5><h5 id="至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的"><a href="#至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的" class="headerlink" title="至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的"></a>至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的</h5><h4 id="48对共享可变数据的同步访问"><a href="#48对共享可变数据的同步访问" class="headerlink" title="48对共享可变数据的同步访问"></a>48对共享可变数据的同步访问</h4><h5 id="为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的"><a href="#为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的" class="headerlink" title="为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的"></a>为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的</h5><h5 id="为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的"><a href="#为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的" class="headerlink" title="为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的"></a>为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的</h5><h5 id="一般情况下，双重检查模式并不能正确地工作"><a href="#一般情况下，双重检查模式并不能正确地工作" class="headerlink" title="一般情况下，双重检查模式并不能正确地工作"></a>一般情况下，双重检查模式并不能正确地工作</h5><h5 id="简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁"><a href="#简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁" class="headerlink" title="简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁"></a>简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁</h5><h4 id="49-避免过多的同步"><a href="#49-避免过多的同步" class="headerlink" title="49.避免过多的同步"></a>49.避免过多的同步</h4><h5 id="为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制"><a href="#为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制" class="headerlink" title="为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制"></a>为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制</h5><h4 id="50-永远不要在循环的外面调用wait"><a href="#50-永远不要在循环的外面调用wait" class="headerlink" title="50.永远不要在循环的外面调用wait"></a>50.永远不要在循环的外面调用wait</h4><h5 id="总是使用wait循环模式来调用wait方法"><a href="#总是使用wait循环模式来调用wait方法" class="headerlink" title="总是使用wait循环模式来调用wait方法"></a>总是使用wait循环模式来调用wait方法</h5><h4 id="51-不要依赖于线程调度器"><a href="#51-不要依赖于线程调度器" class="headerlink" title="51.不要依赖于线程调度器"></a>51.不要依赖于线程调度器</h4><h5 id="任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的"><a href="#任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的" class="headerlink" title="任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的"></a>任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的</h5><h5 id="线程优先级是Java平台上最不可移植的特征了"><a href="#线程优先级是Java平台上最不可移植的特征了" class="headerlink" title="线程优先级是Java平台上最不可移植的特征了"></a>线程优先级是Java平台上最不可移植的特征了</h5><h5 id="对于大多数程序员来说，Thread-yield的惟一用途是在测试期间人为地增加一个程序的并发性"><a href="#对于大多数程序员来说，Thread-yield的惟一用途是在测试期间人为地增加一个程序的并发性" class="headerlink" title="对于大多数程序员来说，Thread.yield的惟一用途是在测试期间人为地增加一个程序的并发性"></a>对于大多数程序员来说，Thread.yield的惟一用途是在测试期间人为地增加一个程序的并发性</h5><h4 id="52-线程安全性的文档化"><a href="#52-线程安全性的文档化" class="headerlink" title="52.线程安全性的文档化"></a>52.线程安全性的文档化</h4><h5 id="在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分"><a href="#在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分" class="headerlink" title="在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分"></a>在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分</h5><h5 id="一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别"><a href="#一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别" class="headerlink" title="一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别"></a>一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别</h5><h5 id="安全级别"><a href="#安全级别" class="headerlink" title="安全级别"></a>安全级别</h5><p><strong>非可变的</strong></p>
<p><strong>线程安全的</strong></p>
<p><strong>有条件的线程安全</strong></p>
<p><strong>线程兼容的</strong></p>
<p><strong>线程对立的</strong></p>
<h4 id="53-避免使用线程组"><a href="#53-避免使用线程组" class="headerlink" title="53.避免使用线程组"></a>53.避免使用线程组</h4><h5 id="线程组基本上已经过时了"><a href="#线程组基本上已经过时了" class="headerlink" title="线程组基本上已经过时了"></a>线程组基本上已经过时了</h5><h4 id="54-谨慎地实现Serialization"><a href="#54-谨慎地实现Serialization" class="headerlink" title="54.谨慎地实现Serialization"></a>54.谨慎地实现Serialization</h4><h5 id="因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低"><a href="#因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低" class="headerlink" title="因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低"></a>因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低</h5><h5 id="实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性"><a href="#实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性" class="headerlink" title="实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性"></a>实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性</h5><h5 id="实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了"><a href="#实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了" class="headerlink" title="实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了"></a>实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了</h5><h5 id="实现Serialization接口不是一个很轻松就可以做出的决定"><a href="#实现Serialization接口不是一个很轻松就可以做出的决定" class="headerlink" title="实现Serialization接口不是一个很轻松就可以做出的决定"></a>实现Serialization接口不是一个很轻松就可以做出的决定</h5><h5 id="为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它"><a href="#为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它" class="headerlink" title="为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它"></a>为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它</h5><h5 id="对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数"><a href="#对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数" class="headerlink" title="对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数"></a>对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数</h5><h4 id="55-考虑使用自定义的序列化形式"><a href="#55-考虑使用自定义的序列化形式" class="headerlink" title="55.考虑使用自定义的序列化形式"></a>55.考虑使用自定义的序列化形式</h4><h5 id="若没有认真考虑默认序列化形式是否合适，则不要接受这种形式"><a href="#若没有认真考虑默认序列化形式是否合适，则不要接受这种形式" class="headerlink" title="若没有认真考虑默认序列化形式是否合适，则不要接受这种形式"></a>若没有认真考虑默认序列化形式是否合适，则不要接受这种形式</h5><h5 id="如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的"><a href="#如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的" class="headerlink" title="如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的"></a>如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的</h5><h5 id="即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性"><a href="#即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性" class="headerlink" title="即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性"></a>即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性</h5><h5 id="当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点："><a href="#当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点：" class="headerlink" title="当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点："></a>当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点：</h5><p><strong>1.它使这个类的导出API永远地束缚在该类的内部表示上</strong></p>
<p><strong>2.它要消耗过多的空间</strong></p>
<p><strong>3.它要消耗过多的时间</strong></p>
<p><strong>4.它会引起栈溢出</strong></p>
<h5 id="transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉"><a href="#transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉" class="headerlink" title="transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉"></a>transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉</h5><h5 id="如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做"><a href="#如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做" class="headerlink" title="如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做"></a>如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做</h5><h5 id="在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分"><a href="#在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分" class="headerlink" title="在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分"></a>在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分</h5><h5 id="不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID-serial-version-UID"><a href="#不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID-serial-version-UID" class="headerlink" title="不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID(serial version UID)"></a>不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID(serial version UID)</h5><h4 id="56-保护性地编写readObject方法"><a href="#56-保护性地编写readObject方法" class="headerlink" title="56.保护性地编写readObject方法"></a>56.保护性地编写readObject方法</h4><h5 id="当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的"><a href="#当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的" class="headerlink" title="当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的"></a>当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的</h5><h4 id="57-必要时提供一个readResolve方法"><a href="#57-必要时提供一个readResolve方法" class="headerlink" title="57.必要时提供一个readResolve方法"></a>57.必要时提供一个readResolve方法</h4><h5 id="readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的"><a href="#readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的" class="headerlink" title="readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的"></a>readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的</h5><h5 id="readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择"><a href="#readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择" class="headerlink" title="readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择"></a>readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择</h5><h5 id="尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑"><a href="#尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑" class="headerlink" title="尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑"></a>尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑</h5><h5 id="readResolve方法的可访问性（accessibility）是非常重要的"><a href="#readResolve方法的可访问性（accessibility）是非常重要的" class="headerlink" title="readResolve方法的可访问性（accessibility）是非常重要的"></a>readResolve方法的可访问性（accessibility）是非常重要的</h5> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://hlp777.github.io/2024/09/17/JAVA%E5%BB%BA%E8%AE%AE/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2023/03/27/hello-world/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hello World</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="huang"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>