<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个简单的博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>并发编程 |  Welcome</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-并发编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  并发编程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/09/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2024-09-19T07:23:51.000Z" itemprop="datePublished">2024-09-19</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">22 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h5 id="1-通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的"><a href="#1-通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的" class="headerlink" title="1.通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的"></a>1.通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的</h5><h5 id="2-设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助"><a href="#2-设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助" class="headerlink" title="2.设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助"></a>2.设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助</h5><h5 id="3-当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全"><a href="#3-当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全" class="headerlink" title="3.当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全"></a>3.当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全</h5><h5 id="4-对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态"><a href="#4-对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态" class="headerlink" title="4.对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态"></a>4.<strong>对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态</strong></h5><h5 id="5-线程安全的类封装了任何必要的同步，因此客户不需要自己提供"><a href="#5-线程安全的类封装了任何必要的同步，因此客户不需要自己提供" class="headerlink" title="5.线程安全的类封装了任何必要的同步，因此客户不需要自己提供"></a>5.线程安全的类封装了任何必要的同步，因此客户不需要自己提供</h5><h5 id="6-无状态对象永远是线程安全的"><a href="#6-无状态对象永远是线程安全的" class="headerlink" title="6.无状态对象永远是线程安全的"></a>6.无状态对象永远是线程安全的</h5><h5 id="7-为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量"><a href="#7-为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量" class="headerlink" title="7.为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量"></a>7.为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量</h5><h5 id="8-对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的"><a href="#8-对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的" class="headerlink" title="8.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的"></a>8.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的</h5><h5 id="9-每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁"><a href="#9-每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁" class="headerlink" title="9.每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁"></a>9.每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁</h5><h5 id="10-对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量"><a href="#10-对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量" class="headerlink" title="10.对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量"></a>10.对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量</h5><h5 id="11-通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）"><a href="#11-通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）" class="headerlink" title="11.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）"></a>11.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）</h5><h5 id="12-有些耗时的计算或操作，比如网络或控制台I-x2F-O，难以快速完成，执行这些操作期间不要占有锁"><a href="#12-有些耗时的计算或操作，比如网络或控制台I-x2F-O，难以快速完成，执行这些操作期间不要占有锁" class="headerlink" title="12.有些耗时的计算或操作，比如网络或控制台I&#x2F;O，难以快速完成，执行这些操作期间不要占有锁"></a>12.有些耗时的计算或操作，比如网络或控制台I&#x2F;O，难以快速完成，执行这些操作期间不要占有锁</h5><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><h5 id="1-在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误"><a href="#1-在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误" class="headerlink" title="1.在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误"></a>1.在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误</h5><h5 id="2-锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步"><a href="#2-锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步" class="headerlink" title="2.锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步"></a>2.锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步</h5><h5 id="3-只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生"><a href="#3-只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生" class="headerlink" title="3.只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生"></a>3.只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生</h5><h5 id="4-枷锁可以保证可见性与原子性，volatile变量只能保证可见性"><a href="#4-枷锁可以保证可见性与原子性，volatile变量只能保证可见性" class="headerlink" title="4.枷锁可以保证可见性与原子性，volatile变量只能保证可见性"></a>4.枷锁可以保证可见性与原子性，volatile变量只能保证可见性</h5><h5 id="5-使用volatile变量的基本要求"><a href="#5-使用volatile变量的基本要求" class="headerlink" title="5.使用volatile变量的基本要求"></a>5.使用volatile变量的基本要求</h5><h5 id="1-写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值"><a href="#1-写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值" class="headerlink" title="1.写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值"></a>1.写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</h5><h5 id="2-变量不需要与其他的状态变量共同参与不变约束"><a href="#2-变量不需要与其他的状态变量共同参与不变约束" class="headerlink" title="2.变量不需要与其他的状态变量共同参与不变约束"></a>2.变量不需要与其他的状态变量共同参与不变约束</h5><h5 id="3-而且，访问变量时，没有其他的原因需要加锁"><a href="#3-而且，访问变量时，没有其他的原因需要加锁" class="headerlink" title="3.而且，访问变量时，没有其他的原因需要加锁"></a>3.而且，访问变量时，没有其他的原因需要加锁</h5><h5 id="6-不要让this引用在构造期间逸出"><a href="#6-不要让this引用在构造期间逸出" class="headerlink" title="6.不要让this引用在构造期间逸出"></a>6.不要让this引用在构造期间逸出</h5><h5 id="7-不可变对象永远是线程安全的"><a href="#7-不可变对象永远是线程安全的" class="headerlink" title="7.不可变对象永远是线程安全的"></a>7.不可变对象永远是线程安全的</h5><h5 id="8-只有满足如下状态，一个对象才是不可变的："><a href="#8-只有满足如下状态，一个对象才是不可变的：" class="headerlink" title="8.只有满足如下状态，一个对象才是不可变的："></a>8.只有满足如下状态，一个对象才是不可变的：</h5><h5 id="1-它的状态不能在创建后再被修改"><a href="#1-它的状态不能在创建后再被修改" class="headerlink" title="1.它的状态不能在创建后再被修改"></a>1.它的状态不能在创建后再被修改</h5><h5 id="2-所有域都是final类型"><a href="#2-所有域都是final类型" class="headerlink" title="2.所有域都是final类型"></a>2.所有域都是final类型</h5><h5 id="3-被正确创建（创建期间没有发生this引用的逸出）"><a href="#3-被正确创建（创建期间没有发生this引用的逸出）" class="headerlink" title="3.被正确创建（创建期间没有发生this引用的逸出）"></a>3.被正确创建（创建期间没有发生this引用的逸出）</h5><h5 id="9-正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践"><a href="#9-正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践" class="headerlink" title="9.正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践"></a>9.正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践</h5><h5 id="10-不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步"><a href="#10-不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步" class="headerlink" title="10.不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步"></a>10.不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步</h5><h5 id="11-为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布："><a href="#11-为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布：" class="headerlink" title="11.为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布："></a>11.为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布：</h5><h5 id="1-通过静态初始化器初始化对象的引用"><a href="#1-通过静态初始化器初始化对象的引用" class="headerlink" title="1.通过静态初始化器初始化对象的引用"></a>1.通过静态初始化器初始化对象的引用</h5><h5 id="2-将它的引用存储到volatile域或AtomicReference"><a href="#2-将它的引用存储到volatile域或AtomicReference" class="headerlink" title="2.将它的引用存储到volatile域或AtomicReference"></a>2.将它的引用存储到volatile域或AtomicReference</h5><h5 id="3-将它的引用存储到正确创建的对象的final域中"><a href="#3-将它的引用存储到正确创建的对象的final域中" class="headerlink" title="3.将它的引用存储到正确创建的对象的final域中"></a>3.将它的引用存储到正确创建的对象的final域中</h5><h5 id="4-或者将它的引用存储到由锁正确保护的域中"><a href="#4-或者将它的引用存储到由锁正确保护的域中" class="headerlink" title="4.或者将它的引用存储到由锁正确保护的域中"></a>4.或者将它的引用存储到由锁正确保护的域中</h5><h5 id="12-任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象"><a href="#12-任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象" class="headerlink" title="12.任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象"></a>12.任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象</h5><h5 id="13-发布对象的必要条件依赖于对象的可变性"><a href="#13-发布对象的必要条件依赖于对象的可变性" class="headerlink" title="13.发布对象的必要条件依赖于对象的可变性"></a>13.发布对象的必要条件依赖于对象的可变性</h5><h5 id="1-不可变对象可以通过任意机制发布"><a href="#1-不可变对象可以通过任意机制发布" class="headerlink" title="1.不可变对象可以通过任意机制发布"></a>1.不可变对象可以通过任意机制发布</h5><h5 id="2-高效不可变对象必须要安全发布"><a href="#2-高效不可变对象必须要安全发布" class="headerlink" title="2.高效不可变对象必须要安全发布"></a>2.高效不可变对象必须要安全发布</h5><h5 id="3-可变对象必须要安全发布，同时必须要线程安全或者时被锁保护"><a href="#3-可变对象必须要安全发布，同时必须要线程安全或者时被锁保护" class="headerlink" title="3.可变对象必须要安全发布，同时必须要线程安全或者时被锁保护"></a>3.可变对象必须要安全发布，同时必须要线程安全或者时被锁保护</h5><h3 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h3><h5 id="1-设计线程安全类的过程应该包括下面3面基本要素："><a href="#1-设计线程安全类的过程应该包括下面3面基本要素：" class="headerlink" title="1.设计线程安全类的过程应该包括下面3面基本要素："></a>1.设计线程安全类的过程应该包括下面3面基本要素：</h5><h5 id="1-确定对象状态是由那些变量构成的"><a href="#1-确定对象状态是由那些变量构成的" class="headerlink" title="1.确定对象状态是由那些变量构成的"></a>1.确定对象状态是由那些变量构成的</h5><h5 id="2-确定限制状态变量的不变约束"><a href="#2-确定限制状态变量的不变约束" class="headerlink" title="2.确定限制状态变量的不变约束"></a>2.确定限制状态变量的不变约束</h5><h5 id="3-制定一个管理并发访问对象状态的策略"><a href="#3-制定一个管理并发访问对象状态的策略" class="headerlink" title="3.制定一个管理并发访问对象状态的策略"></a>3.制定一个管理并发访问对象状态的策略</h5><h5 id="2-不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0"><a href="#2-不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0" class="headerlink" title="2.不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0"></a>2.不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0</h5><h5 id="3-将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁"><a href="#3-将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁" class="headerlink" title="3.将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁"></a>3.将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁</h5><h5 id="4-限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序"><a href="#4-限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序" class="headerlink" title="4.限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序"></a>4.限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序</h5><h5 id="5-如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量"><a href="#5-如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量" class="headerlink" title="5.如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量"></a>5.如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量</h5><h5 id="6-如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布"><a href="#6-如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布" class="headerlink" title="6.如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布"></a>6.如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布</h5><h5 id="7-为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档"><a href="#7-为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档" class="headerlink" title="7.为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档"></a>7.为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档</h5><h3 id="构建块"><a href="#构建块" class="headerlink" title="构建块"></a>构建块</h3><h5 id="1-正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略"><a href="#1-正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略" class="headerlink" title="1.正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略"></a>1.正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略</h5><h5 id="2-用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高"><a href="#2-用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高" class="headerlink" title="2.用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高"></a>2.用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高</h5><h5 id="3-相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）"><a href="#3-相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）" class="headerlink" title="3.相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）"></a>3.相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）</h5><h5 id="4-有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮"><a href="#4-有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮" class="headerlink" title="4.有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮"></a>4.有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮</h5><h3 id="第一部分总结"><a href="#第一部分总结" class="headerlink" title="第一部分总结"></a>第一部分总结</h3><h5 id="1-所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易"><a href="#1-所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易" class="headerlink" title="1.所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易"></a>1.所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易</h5><h5 id="2-尽量将域声明为final类型，除非它们的需要是可变的"><a href="#2-尽量将域声明为final类型，除非它们的需要是可变的" class="headerlink" title="2.尽量将域声明为final类型，除非它们的需要是可变的"></a>2.尽量将域声明为final类型，除非它们的需要是可变的</h5><h5 id="3-不可变对象天生是线程安全的"><a href="#3-不可变对象天生是线程安全的" class="headerlink" title="3.不可变对象天生是线程安全的"></a>3.不可变对象天生是线程安全的</h5><h5 id="4-不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享"><a href="#4-不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享" class="headerlink" title="4.不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享"></a>4.不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享</h5><h5 id="5-封装使管理复杂度变得更可行"><a href="#5-封装使管理复杂度变得更可行" class="headerlink" title="5.封装使管理复杂度变得更可行"></a>5.封装使管理复杂度变得更可行</h5><h5 id="6-用锁来守护每一个可变变量"><a href="#6-用锁来守护每一个可变变量" class="headerlink" title="6.用锁来守护每一个可变变量"></a>6.用锁来守护每一个可变变量</h5><h5 id="7-对同一不变约束中的所有变量都使用相同的锁"><a href="#7-对同一不变约束中的所有变量都使用相同的锁" class="headerlink" title="7.对同一不变约束中的所有变量都使用相同的锁"></a>7.对同一不变约束中的所有变量都使用相同的锁</h5><h5 id="8-在运行复合操作期间持有锁"><a href="#8-在运行复合操作期间持有锁" class="headerlink" title="8.在运行复合操作期间持有锁"></a>8.在运行复合操作期间持有锁</h5><h5 id="9-在非同步的多线程情况下，访问可变变量的程序是存在隐患的"><a href="#9-在非同步的多线程情况下，访问可变变量的程序是存在隐患的" class="headerlink" title="9.在非同步的多线程情况下，访问可变变量的程序是存在隐患的"></a>9.在非同步的多线程情况下，访问可变变量的程序是存在隐患的</h5><h5 id="10-不要依赖于可以需要同步的小聪明"><a href="#10-不要依赖于可以需要同步的小聪明" class="headerlink" title="10.不要依赖于可以需要同步的小聪明"></a>10.不要依赖于可以需要同步的小聪明</h5><h5 id="11-在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的"><a href="#11-在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的" class="headerlink" title="11.在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的"></a>11.在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的</h5><h5 id="12-文档化你的同步策略"><a href="#12-文档化你的同步策略" class="headerlink" title="12.文档化你的同步策略"></a>12.文档化你的同步策略</h5><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="构建并发应用程序"><a href="#构建并发应用程序" class="headerlink" title="构建并发应用程序"></a>构建并发应用程序</h3><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><h5 id="1-如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式"><a href="#1-如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式" class="headerlink" title="1.如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式"></a>1.如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式</h5><h5 id="2-无论何时当你看到这种形式的代码："><a href="#2-无论何时当你看到这种形式的代码：" class="headerlink" title="2.无论何时当你看到这种形式的代码："></a>2.无论何时当你看到这种形式的代码：</h5><h5 id="new-Thread-runnable-start"><a href="#new-Thread-runnable-start" class="headerlink" title="new Thread(runnable).start()"></a>new Thread(runnable).start()</h5><h5 id="并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread"><a href="#并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread" class="headerlink" title="并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread"></a>并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread</h5><h5 id="3-Executors中的静态工厂方法"><a href="#3-Executors中的静态工厂方法" class="headerlink" title="3.Executors中的静态工厂方法"></a>3.Executors中的静态工厂方法</h5><p><img src="E:\图片\Typora\并发编程\image-20230921090327806.png" alt="image-20230921090327806"></p>
<h5 id="4-大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升"><a href="#4-大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升" class="headerlink" title="4.大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升"></a>4.大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升</h5><h3 id="取消和关闭"><a href="#取消和关闭" class="headerlink" title="取消和关闭"></a>取消和关闭</h3><h5 id="1-在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用"><a href="#1-在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用" class="headerlink" title="1.在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用"></a>1.在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用</h5><h5 id="2-调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息"><a href="#2-调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息" class="headerlink" title="2.调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息"></a>2.调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息</h5><h5 id="3-中断通常是实现取消最明智的选择"><a href="#3-中断通常是实现取消最明智的选择" class="headerlink" title="3.中断通常是实现取消最明智的选择"></a>3.中断通常是实现取消最明智的选择</h5><h5 id="4-因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么"><a href="#4-因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么" class="headerlink" title="4.因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么"></a>4.因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么</h5><h5 id="5-只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求"><a href="#5-只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求" class="headerlink" title="5.只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求"></a>5.只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求</h5><h5 id="6-对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法"><a href="#6-对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法" class="headerlink" title="6.对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法"></a>6.对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法</h5><h5 id="7-在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中"><a href="#7-在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中" class="headerlink" title="7.在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中"></a>7.在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中</h5><h4 id="精灵线程"><a href="#精灵线程" class="headerlink" title="精灵线程"></a>精灵线程</h4><h5 id="8-线程被分为两种：普通线程和精灵线程（daemon-thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。"><a href="#8-线程被分为两种：普通线程和精灵线程（daemon-thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。" class="headerlink" title="8.线程被分为两种：普通线程和精灵线程（daemon thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。"></a>8.线程被分为两种：普通线程和精灵线程（daemon thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。</h5><h5 id="9-普通线程和精灵线程之间的差别仅仅在于退出时会发生什么"><a href="#9-普通线程和精灵线程之间的差别仅仅在于退出时会发生什么" class="headerlink" title="9.普通线程和精灵线程之间的差别仅仅在于退出时会发生什么"></a>9.普通线程和精灵线程之间的差别仅仅在于退出时会发生什么</h5><h5 id="10-应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理"><a href="#10-应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理" class="headerlink" title="10.应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理"></a>10.应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理</h5><h5 id="11-避免使用finalizer"><a href="#11-避免使用finalizer" class="headerlink" title="11.避免使用finalizer"></a>11.避免使用finalizer</h5><h3 id="应用线程池"><a href="#应用线程池" class="headerlink" title="应用线程池"></a>应用线程池</h3><h5 id="1-一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度"><a href="#1-一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度" class="headerlink" title="1.一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度"></a>1.一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度</h5><h5 id="2-无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档"><a href="#2-无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档" class="headerlink" title="2.无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档"></a>2.无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档</h5><h5 id="3-newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。"><a href="#3-newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。" class="headerlink" title="3.newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。"></a>3.newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。</h5><h5 id="4-当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的"><a href="#4-当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的" class="headerlink" title="4.当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的"></a>4.当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果"><a href="#对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果" class="headerlink" title="对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果"></a>对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果</h5><h3 id="GUI应用程序"><a href="#GUI应用程序" class="headerlink" title="GUI应用程序"></a>GUI应用程序</h3><h5 id="1-Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求"><a href="#1-Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求" class="headerlink" title="1.Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求"></a>1.Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求</h5><h5 id="2-如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计"><a href="#2-如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计" class="headerlink" title="2.如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计"></a>2.如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计</h5><h5 id="3-GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持-x2F-无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发"><a href="#3-GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持-x2F-无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发" class="headerlink" title="3.GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持&#x2F;无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发"></a>3.GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持&#x2F;无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发</h5><h3 id="活跃度，性能和测试"><a href="#活跃度，性能和测试" class="headerlink" title="活跃度，性能和测试"></a>活跃度，性能和测试</h3><h4 id="避免活跃度危险"><a href="#避免活跃度危险" class="headerlink" title="避免活跃度危险"></a>避免活跃度危险</h4><h5 id="1-安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering-deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource-deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的"><a href="#1-安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering-deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource-deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的" class="headerlink" title="1.安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的"></a>1.安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的</h5><h5 id="2-如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了"><a href="#2-如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了" class="headerlink" title="2.如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了"></a>2.如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了</h5><h5 id="3-在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程"><a href="#3-在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程" class="headerlink" title="3.在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程"></a>3.在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程</h5><h5 id="4-当调用的方法不需要持有锁时，这被称为开放调用"><a href="#4-当调用的方法不需要持有锁时，这被称为开放调用" class="headerlink" title="4.当调用的方法不需要持有锁时，这被称为开放调用"></a>4.当调用的方法不需要持有锁时，这被称为开放调用</h5><h5 id="5-在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析"><a href="#5-在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析" class="headerlink" title="5.在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析"></a>5.在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析</h5><h5 id="6-抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级"><a href="#6-抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级" class="headerlink" title="6.抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级"></a>6.抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级</h5><h5 id="7-可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I-x2F-O带宽），吞吐量和生产量能够相应地得以改进"><a href="#7-可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I-x2F-O带宽），吞吐量和生产量能够相应地得以改进" class="headerlink" title="7.可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I&#x2F;O带宽），吞吐量和生产量能够相应地得以改进"></a>7.可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I&#x2F;O带宽），吞吐量和生产量能够相应地得以改进</h5><h5 id="8-避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快"><a href="#8-避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快" class="headerlink" title="8.避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快"></a>8.避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快</h5><h5 id="9-测评。不要臆测"><a href="#9-测评。不要臆测" class="headerlink" title="9.测评。不要臆测"></a>9.测评。不要臆测</h5><h5 id="10-所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧"><a href="#10-所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧" class="headerlink" title="10.所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧"></a>10.所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧</h5><h5 id="11-不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化"><a href="#11-不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化" class="headerlink" title="11.不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化"></a>11.不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化</h5><h5 id="12-串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性"><a href="#12-串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性" class="headerlink" title="12.串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性"></a>12.串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性</h5><h5 id="13-并发程序中，对可伸缩性首要的威胁是独占的资源锁"><a href="#13-并发程序中，对可伸缩性首要的威胁是独占的资源锁" class="headerlink" title="13.并发程序中，对可伸缩性首要的威胁是独占的资源锁"></a>13.并发程序中，对可伸缩性首要的威胁是独占的资源锁</h5><h5 id="14-三种方式来减少锁的竞争"><a href="#14-三种方式来减少锁的竞争" class="headerlink" title="14.三种方式来减少锁的竞争"></a>14.三种方式来减少锁的竞争</h5><h5 id="1-减少持有锁的时间"><a href="#1-减少持有锁的时间" class="headerlink" title="1.减少持有锁的时间"></a>1.减少持有锁的时间</h5><h5 id="2-减少请求锁的频率"><a href="#2-减少请求锁的频率" class="headerlink" title="2.减少请求锁的频率"></a>2.减少请求锁的频率</h5><h5 id="3-或者用协调机制取代独占锁，从而允许更强的并发性"><a href="#3-或者用协调机制取代独占锁，从而允许更强的并发性" class="headerlink" title="3.或者用协调机制取代独占锁，从而允许更强的并发性"></a>3.或者用协调机制取代独占锁，从而允许更强的并发性</h5><h5 id="15-Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的"><a href="#15-Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的" class="headerlink" title="15.Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的"></a>15.Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的</h5><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h5 id="16-可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁"><a href="#16-可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁" class="headerlink" title="16.可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁"></a>16.可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁</h5><h3 id="测试并发程序"><a href="#测试并发程序" class="headerlink" title="测试并发程序"></a>测试并发程序</h3><h5 id="1-为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。"><a href="#1-为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。" class="headerlink" title="1.为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。"></a>1.为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。</h5><h5 id="2-测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性"><a href="#2-测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性" class="headerlink" title="2.测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性"></a>2.测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性</h5><h5 id="3-编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式"><a href="#3-编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式" class="headerlink" title="3.编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式"></a>3.编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式</h5><h3 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h3><h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><h5 id="1-性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了"><a href="#1-性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了" class="headerlink" title="1.性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了"></a>1.性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了</h5><h5 id="2-正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了"><a href="#2-正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了" class="headerlink" title="2.正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了"></a>2.正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了</h5><h5 id="3-在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized"><a href="#3-在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized" class="headerlink" title="3.在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized"></a>3.在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized</h5><h5 id="4-读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力"><a href="#4-读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力" class="headerlink" title="4.读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力"></a>4.读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力</h5><h3 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h3><h5 id="1-条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系"><a href="#1-条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系" class="headerlink" title="1.条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系"></a>1.条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系</h5><h5 id="2-将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档"><a href="#2-将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档" class="headerlink" title="2.将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档"></a>2.将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档</h5><h5 id="3-每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量"><a href="#3-每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量" class="headerlink" title="3.每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量"></a>3.每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量</h5><h5 id="4-一个单独的内部条件队列可以与多个条件谓词共同使用"><a href="#4-一个单独的内部条件队列可以与多个条件谓词共同使用" class="headerlink" title="4.一个单独的内部条件队列可以与多个条件谓词共同使用"></a>4.一个单独的内部条件队列可以与多个条件谓词共同使用</h5><h5 id="5-当使用条件等待（Object-wait或者Condition。await）"><a href="#5-当使用条件等待（Object-wait或者Condition。await）" class="headerlink" title="5.当使用条件等待（Object.wait或者Condition。await）"></a>5.当使用条件等待（Object.wait或者Condition。await）</h5><h5 id="1-永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；"><a href="#1-永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；" class="headerlink" title="1.永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；"></a>1.永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；</h5><h5 id="2-永远在调用wait前测试条件谓词，并且从wait中返回后再次测试"><a href="#2-永远在调用wait前测试条件谓词，并且从wait中返回后再次测试" class="headerlink" title="2.永远在调用wait前测试条件谓词，并且从wait中返回后再次测试"></a>2.永远在调用wait前测试条件谓词，并且从wait中返回后再次测试</h5><h5 id="3-永远在循环中调用wait"><a href="#3-永远在循环中调用wait" class="headerlink" title="3.永远在循环中调用wait"></a>3.永远在循环中调用wait</h5><h5 id="4-确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；"><a href="#4-确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；" class="headerlink" title="4.确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；"></a>4.确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；</h5><h5 id="5-当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且"><a href="#5-当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且" class="headerlink" title="5.当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且"></a>5.当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且</h5><h5 id="6-在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁"><a href="#6-在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁" class="headerlink" title="6.在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁"></a>6.在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁</h5><h5 id="7-无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你"><a href="#7-无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你" class="headerlink" title="7.无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你"></a>7.无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你</h5><h5 id="8-只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行"><a href="#8-只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行" class="headerlink" title="8.只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行"></a>8.只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行</h5><h5 id="9-尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的"><a href="#9-尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的" class="headerlink" title="9.尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的"></a>9.尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的</h5><h5 id="10-一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中"><a href="#10-一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中" class="headerlink" title="10.一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中"></a>10.一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中</h5><h5 id="11-危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！"><a href="#11-危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！" class="headerlink" title="11.危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！"></a>11.危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！</h5><h3 id="原子变量与非阻塞同步机制"><a href="#原子变量与非阻塞同步机制" class="headerlink" title="原子变量与非阻塞同步机制"></a>原子变量与非阻塞同步机制</h3><h5 id="1-如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的"><a href="#1-如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的" class="headerlink" title="1.如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的"></a>1.如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的</h5><h5 id="2-非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作"><a href="#2-非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作" class="headerlink" title="2.非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作"></a>2.非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作</h5><h5 id="3-非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。"><a href="#3-非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。" class="headerlink" title="3.非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。"></a>3.非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。</h5><h3 id="Java存储模型"><a href="#Java存储模型" class="headerlink" title="Java存储模型"></a>Java存储模型</h3><h5 id="1-happens-before的法则包括："><a href="#1-happens-before的法则包括：" class="headerlink" title="1.happens-before的法则包括："></a>1.happens-before的法则包括：</h5><h5 id="程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后"><a href="#程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后" class="headerlink" title="程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后"></a>程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后</h5><h5 id="监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。"><a href="#监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。" class="headerlink" title="监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。"></a>监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。</h5><h5 id="volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。"><a href="#volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。" class="headerlink" title="volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。"></a>volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。</h5><h5 id="线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动程序中的动作"><a href="#线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动程序中的动作" class="headerlink" title="线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动程序中的动作"></a>线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动程序中的动作</h5><h5 id="线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动线程中的动作"><a href="#线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动线程中的动作" class="headerlink" title="线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动线程中的动作"></a>线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动线程中的动作</h5><h5 id="线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread-join调用中成功返回，或者Thread-isAlive返回false。"><a href="#线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread-join调用中成功返回，或者Thread-isAlive返回false。" class="headerlink" title="线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或者Thread.isAlive返回false。"></a>线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或者Thread.isAlive返回false。</h5><h5 id="中断法制：一个线程调用另一个线程的interrupt-happens-before-于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）"><a href="#中断法制：一个线程调用另一个线程的interrupt-happens-before-于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）" class="headerlink" title="中断法制：一个线程调用另一个线程的interrupt happens-before 于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）"></a>中断法制：一个线程调用另一个线程的interrupt happens-before 于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）</h5><h5 id="终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。"><a href="#终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。" class="headerlink" title="终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。"></a>终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</h5><h5 id="传递性：如果A-happens-before于B，且B-happens-before-于C，则A-happens-before于C"><a href="#传递性：如果A-happens-before于B，且B-happens-before-于C，则A-happens-before于C" class="headerlink" title="传递性：如果A happens-before于B，且B happens-before 于C，则A happens-before于C"></a>传递性：如果A happens-before于B，且B happens-before 于C，则A happens-before于C</h5><h5 id="2-除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它"><a href="#2-除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它" class="headerlink" title="2.除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它"></a>2.除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它</h5><h5 id="3-初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。"><a href="#3-初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。" class="headerlink" title="3.初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。"></a>3.初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。</h5><h5 id="4-初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。"><a href="#4-初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。" class="headerlink" title="4.初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。"></a>4.初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。</h5><h3 id="同步Annotation"><a href="#同步Annotation" class="headerlink" title="同步Annotation"></a>同步Annotation</h3><h5 id="3个类级Annotation来描述类的可预期的线程安全性保证：-Immutable-，-ThreadSafe-和-NotThreadSafe"><a href="#3个类级Annotation来描述类的可预期的线程安全性保证：-Immutable-，-ThreadSafe-和-NotThreadSafe" class="headerlink" title="3个类级Annotation来描述类的可预期的线程安全性保证：@Immutable ，@ThreadSafe 和 @NotThreadSafe"></a>3个类级Annotation来描述类的可预期的线程安全性保证：@Immutable ，@ThreadSafe 和 @NotThreadSafe</h5><p><strong>@Immutable自然是意味着类是不可变的，并包含了@ThreadSafe的意义。@NotThreadSafe是可选的–如果类没有被标明是线程安全的，就无法肯定它是不是线程安全的，但是如果你想明确地表示出它不是线程安全的，就标注为@NotThreadSafe</strong></p>
<p><strong>这些Annotation相对是非侵入的，这对用户和维护者都是有益的。用户可以立即看出一个类是否线程安全的，维护者也可以直接检查是否遵循了线程安全性保证。Annotation对于第三个利益既得者也是有用的：工具。静态的代码分析工具可以有能力对代码进行验证，看它是否遵循了由Annotation指定的契约，比如标明为@Immutable的类是否真是不可变的</strong></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://hlp777.github.io/2024/09/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            设计模式
          
        </div>
      </a>
    
    
      <a href="/2024/09/17/JAVA%E5%BB%BA%E8%AE%AE/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JAVA建议</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> lp Huang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Welcome"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>