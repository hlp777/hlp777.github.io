<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2024/09/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h5 id="1-通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的"><a href="#1-通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的" class="headerlink" title="1.通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的"></a>1.通过从框架线程中调用应用程序的组件，框架把并发引入了应用程序。组件总是需要访问程序的状态。因此要求在所有代码路径访问状态时，必须时线程安全的</h5><h5 id="2-设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助"><a href="#2-设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助" class="headerlink" title="2.设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助"></a>2.设计线程安全的类时，优秀的面向对象技术–封装，不可变性以及明确的不变约束–会给你提供诸多的帮助</h5><h5 id="3-当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全"><a href="#3-当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全" class="headerlink" title="3.当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全"></a>3.当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全</h5><h5 id="4-对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态"><a href="#4-对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态" class="headerlink" title="4.对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态"></a>4.<strong>对于线程安全类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态</strong></h5><h5 id="5-线程安全的类封装了任何必要的同步，因此客户不需要自己提供"><a href="#5-线程安全的类封装了任何必要的同步，因此客户不需要自己提供" class="headerlink" title="5.线程安全的类封装了任何必要的同步，因此客户不需要自己提供"></a>5.线程安全的类封装了任何必要的同步，因此客户不需要自己提供</h5><h5 id="6-无状态对象永远是线程安全的"><a href="#6-无状态对象永远是线程安全的" class="headerlink" title="6.无状态对象永远是线程安全的"></a>6.无状态对象永远是线程安全的</h5><h5 id="7-为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量"><a href="#7-为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量" class="headerlink" title="7.为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量"></a>7.为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量</h5><h5 id="8-对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的"><a href="#8-对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的" class="headerlink" title="8.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的"></a>8.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的</h5><h5 id="9-每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁"><a href="#9-每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁" class="headerlink" title="9.每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁"></a>9.每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁</h5><h5 id="10-对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量"><a href="#10-对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量" class="headerlink" title="10.对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量"></a>10.对于每个涉及多个变量的不变约束，需要同一个锁保护其所有的变量</h5><h5 id="11-通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）"><a href="#11-通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）" class="headerlink" title="11.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）"></a>11.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地维克性能而牺牲简单性（这是对安全性潜在的妥协）</h5><h5 id="12-有些耗时的计算或操作，比如网络或控制台I-x2F-O，难以快速完成，执行这些操作期间不要占有锁"><a href="#12-有些耗时的计算或操作，比如网络或控制台I-x2F-O，难以快速完成，执行这些操作期间不要占有锁" class="headerlink" title="12.有些耗时的计算或操作，比如网络或控制台I&#x2F;O，难以快速完成，执行这些操作期间不要占有锁"></a>12.有些耗时的计算或操作，比如网络或控制台I&#x2F;O，难以快速完成，执行这些操作期间不要占有锁</h5><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><h5 id="1-在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误"><a href="#1-在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误" class="headerlink" title="1.在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误"></a>1.在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是会判断错误</h5><h5 id="2-锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步"><a href="#2-锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步" class="headerlink" title="2.锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步"></a>2.锁不仅仅是关于同步与互斥的，也是关于内存可见的，为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步</h5><h5 id="3-只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生"><a href="#3-只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生" class="headerlink" title="3.只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生"></a>3.只由当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件（比如初始化或关闭）的发生</h5><h5 id="4-枷锁可以保证可见性与原子性，volatile变量只能保证可见性"><a href="#4-枷锁可以保证可见性与原子性，volatile变量只能保证可见性" class="headerlink" title="4.枷锁可以保证可见性与原子性，volatile变量只能保证可见性"></a>4.枷锁可以保证可见性与原子性，volatile变量只能保证可见性</h5><h5 id="5-使用volatile变量的基本要求"><a href="#5-使用volatile变量的基本要求" class="headerlink" title="5.使用volatile变量的基本要求"></a>5.使用volatile变量的基本要求</h5><h5 id="1-写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值"><a href="#1-写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值" class="headerlink" title="1.写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值"></a>1.写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</h5><h5 id="2-变量不需要与其他的状态变量共同参与不变约束"><a href="#2-变量不需要与其他的状态变量共同参与不变约束" class="headerlink" title="2.变量不需要与其他的状态变量共同参与不变约束"></a>2.变量不需要与其他的状态变量共同参与不变约束</h5><h5 id="3-而且，访问变量时，没有其他的原因需要加锁"><a href="#3-而且，访问变量时，没有其他的原因需要加锁" class="headerlink" title="3.而且，访问变量时，没有其他的原因需要加锁"></a>3.而且，访问变量时，没有其他的原因需要加锁</h5><h5 id="6-不要让this引用在构造期间逸出"><a href="#6-不要让this引用在构造期间逸出" class="headerlink" title="6.不要让this引用在构造期间逸出"></a>6.不要让this引用在构造期间逸出</h5><h5 id="7-不可变对象永远是线程安全的"><a href="#7-不可变对象永远是线程安全的" class="headerlink" title="7.不可变对象永远是线程安全的"></a>7.不可变对象永远是线程安全的</h5><h5 id="8-只有满足如下状态，一个对象才是不可变的："><a href="#8-只有满足如下状态，一个对象才是不可变的：" class="headerlink" title="8.只有满足如下状态，一个对象才是不可变的："></a>8.只有满足如下状态，一个对象才是不可变的：</h5><h5 id="1-它的状态不能在创建后再被修改"><a href="#1-它的状态不能在创建后再被修改" class="headerlink" title="1.它的状态不能在创建后再被修改"></a>1.它的状态不能在创建后再被修改</h5><h5 id="2-所有域都是final类型"><a href="#2-所有域都是final类型" class="headerlink" title="2.所有域都是final类型"></a>2.所有域都是final类型</h5><h5 id="3-被正确创建（创建期间没有发生this引用的逸出）"><a href="#3-被正确创建（创建期间没有发生this引用的逸出）" class="headerlink" title="3.被正确创建（创建期间没有发生this引用的逸出）"></a>3.被正确创建（创建期间没有发生this引用的逸出）</h5><h5 id="9-正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践"><a href="#9-正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践" class="headerlink" title="9.正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践"></a>9.正如“将所有的域声明为私有的，除非它们需要更高的可见性”一样，“将所有的域声明为final型，除非它们是可变的”，也是一条良好的实践</h5><h5 id="10-不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步"><a href="#10-不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步" class="headerlink" title="10.不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步"></a>10.不可变对象可以在没有额外同步的情况下，安全地用于任意线程，甚至发布它们时亦不需要同步</h5><h5 id="11-为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布："><a href="#11-为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布：" class="headerlink" title="11.为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布："></a>11.为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全地发布：</h5><h5 id="1-通过静态初始化器初始化对象的引用"><a href="#1-通过静态初始化器初始化对象的引用" class="headerlink" title="1.通过静态初始化器初始化对象的引用"></a>1.通过静态初始化器初始化对象的引用</h5><h5 id="2-将它的引用存储到volatile域或AtomicReference"><a href="#2-将它的引用存储到volatile域或AtomicReference" class="headerlink" title="2.将它的引用存储到volatile域或AtomicReference"></a>2.将它的引用存储到volatile域或AtomicReference</h5><h5 id="3-将它的引用存储到正确创建的对象的final域中"><a href="#3-将它的引用存储到正确创建的对象的final域中" class="headerlink" title="3.将它的引用存储到正确创建的对象的final域中"></a>3.将它的引用存储到正确创建的对象的final域中</h5><h5 id="4-或者将它的引用存储到由锁正确保护的域中"><a href="#4-或者将它的引用存储到由锁正确保护的域中" class="headerlink" title="4.或者将它的引用存储到由锁正确保护的域中"></a>4.或者将它的引用存储到由锁正确保护的域中</h5><h5 id="12-任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象"><a href="#12-任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象" class="headerlink" title="12.任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象"></a>12.任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象</h5><h5 id="13-发布对象的必要条件依赖于对象的可变性"><a href="#13-发布对象的必要条件依赖于对象的可变性" class="headerlink" title="13.发布对象的必要条件依赖于对象的可变性"></a>13.发布对象的必要条件依赖于对象的可变性</h5><h5 id="1-不可变对象可以通过任意机制发布"><a href="#1-不可变对象可以通过任意机制发布" class="headerlink" title="1.不可变对象可以通过任意机制发布"></a>1.不可变对象可以通过任意机制发布</h5><h5 id="2-高效不可变对象必须要安全发布"><a href="#2-高效不可变对象必须要安全发布" class="headerlink" title="2.高效不可变对象必须要安全发布"></a>2.高效不可变对象必须要安全发布</h5><h5 id="3-可变对象必须要安全发布，同时必须要线程安全或者时被锁保护"><a href="#3-可变对象必须要安全发布，同时必须要线程安全或者时被锁保护" class="headerlink" title="3.可变对象必须要安全发布，同时必须要线程安全或者时被锁保护"></a>3.可变对象必须要安全发布，同时必须要线程安全或者时被锁保护</h5><h3 id="组合对象"><a href="#组合对象" class="headerlink" title="组合对象"></a>组合对象</h3><h5 id="1-设计线程安全类的过程应该包括下面3面基本要素："><a href="#1-设计线程安全类的过程应该包括下面3面基本要素：" class="headerlink" title="1.设计线程安全类的过程应该包括下面3面基本要素："></a>1.设计线程安全类的过程应该包括下面3面基本要素：</h5><h5 id="1-确定对象状态是由那些变量构成的"><a href="#1-确定对象状态是由那些变量构成的" class="headerlink" title="1.确定对象状态是由那些变量构成的"></a>1.确定对象状态是由那些变量构成的</h5><h5 id="2-确定限制状态变量的不变约束"><a href="#2-确定限制状态变量的不变约束" class="headerlink" title="2.确定限制状态变量的不变约束"></a>2.确定限制状态变量的不变约束</h5><h5 id="3-制定一个管理并发访问对象状态的策略"><a href="#3-制定一个管理并发访问对象状态的策略" class="headerlink" title="3.制定一个管理并发访问对象状态的策略"></a>3.制定一个管理并发访问对象状态的策略</h5><h5 id="2-不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0"><a href="#2-不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0" class="headerlink" title="2.不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0"></a>2.不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性0</h5><h5 id="3-将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁"><a href="#3-将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁" class="headerlink" title="3.将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁"></a>3.将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁</h5><h5 id="4-限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序"><a href="#4-限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序" class="headerlink" title="4.限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序"></a>4.限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序</h5><h5 id="5-如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量"><a href="#5-如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量" class="headerlink" title="5.如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量"></a>5.如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量</h5><h5 id="6-如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布"><a href="#6-如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布" class="headerlink" title="6.如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布"></a>6.如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布</h5><h5 id="7-为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档"><a href="#7-为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档" class="headerlink" title="7.为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档"></a>7.为类的用户编写类线程安全性担保的文档，为类的维护者编写类的同步策略文档</h5><h3 id="构建块"><a href="#构建块" class="headerlink" title="构建块"></a>构建块</h3><h5 id="1-正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略"><a href="#1-正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略" class="headerlink" title="1.正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略"></a>1.正如封装一个对象的状态，能够使它更加容易地保持不变约束一样，封装它的同步则可以迫使它符合同步策略</h5><h5 id="2-用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高"><a href="#2-用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高" class="headerlink" title="2.用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高"></a>2.用并发容器替换同步容器，这种作法以有很小风险带来了可扩展性显著的提高</h5><h5 id="3-相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）"><a href="#3-相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）" class="headerlink" title="3.相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）"></a>3.相比于Hashtable和synchronizedMap，ConcurrentHashMap有众多的优势，而且几乎不存在什么劣势，因此在大多数情况下用ConcurrentHashMap取代同步Map实现只会带来更好的可伸缩性。只有当你的程序需要在独占访问中加锁时，ConurrentHashMap才无法胜任（ConcurrentHashMap是线程安全的）</h5><h5 id="4-有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮"><a href="#4-有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮" class="headerlink" title="4.有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮"></a>4.有界队列是强大的资源管理工具，用来建立可靠的应用程序，它们遏制那些可以产生过多工作量，具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮</h5><h3 id="第一部分总结"><a href="#第一部分总结" class="headerlink" title="第一部分总结"></a>第一部分总结</h3><h5 id="1-所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易"><a href="#1-所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易" class="headerlink" title="1.所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易"></a>1.所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越发容易</h5><h5 id="2-尽量将域声明为final类型，除非它们的需要是可变的"><a href="#2-尽量将域声明为final类型，除非它们的需要是可变的" class="headerlink" title="2.尽量将域声明为final类型，除非它们的需要是可变的"></a>2.尽量将域声明为final类型，除非它们的需要是可变的</h5><h5 id="3-不可变对象天生是线程安全的"><a href="#3-不可变对象天生是线程安全的" class="headerlink" title="3.不可变对象天生是线程安全的"></a>3.不可变对象天生是线程安全的</h5><h5 id="4-不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享"><a href="#4-不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享" class="headerlink" title="4.不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享"></a>4.不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享</h5><h5 id="5-封装使管理复杂度变得更可行"><a href="#5-封装使管理复杂度变得更可行" class="headerlink" title="5.封装使管理复杂度变得更可行"></a>5.封装使管理复杂度变得更可行</h5><h5 id="6-用锁来守护每一个可变变量"><a href="#6-用锁来守护每一个可变变量" class="headerlink" title="6.用锁来守护每一个可变变量"></a>6.用锁来守护每一个可变变量</h5><h5 id="7-对同一不变约束中的所有变量都使用相同的锁"><a href="#7-对同一不变约束中的所有变量都使用相同的锁" class="headerlink" title="7.对同一不变约束中的所有变量都使用相同的锁"></a>7.对同一不变约束中的所有变量都使用相同的锁</h5><h5 id="8-在运行复合操作期间持有锁"><a href="#8-在运行复合操作期间持有锁" class="headerlink" title="8.在运行复合操作期间持有锁"></a>8.在运行复合操作期间持有锁</h5><h5 id="9-在非同步的多线程情况下，访问可变变量的程序是存在隐患的"><a href="#9-在非同步的多线程情况下，访问可变变量的程序是存在隐患的" class="headerlink" title="9.在非同步的多线程情况下，访问可变变量的程序是存在隐患的"></a>9.在非同步的多线程情况下，访问可变变量的程序是存在隐患的</h5><h5 id="10-不要依赖于可以需要同步的小聪明"><a href="#10-不要依赖于可以需要同步的小聪明" class="headerlink" title="10.不要依赖于可以需要同步的小聪明"></a>10.不要依赖于可以需要同步的小聪明</h5><h5 id="11-在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的"><a href="#11-在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的" class="headerlink" title="11.在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的"></a>11.在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的</h5><h5 id="12-文档化你的同步策略"><a href="#12-文档化你的同步策略" class="headerlink" title="12.文档化你的同步策略"></a>12.文档化你的同步策略</h5><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="构建并发应用程序"><a href="#构建并发应用程序" class="headerlink" title="构建并发应用程序"></a>构建并发应用程序</h3><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><h5 id="1-如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式"><a href="#1-如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式" class="headerlink" title="1.如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式"></a>1.如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式</h5><h5 id="2-无论何时当你看到这种形式的代码："><a href="#2-无论何时当你看到这种形式的代码：" class="headerlink" title="2.无论何时当你看到这种形式的代码："></a>2.无论何时当你看到这种形式的代码：</h5><h5 id="new-Thread-runnable-start"><a href="#new-Thread-runnable-start" class="headerlink" title="new Thread(runnable).start()"></a>new Thread(runnable).start()</h5><h5 id="并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread"><a href="#并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread" class="headerlink" title="并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread"></a>并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread</h5><h5 id="3-Executors中的静态工厂方法"><a href="#3-Executors中的静态工厂方法" class="headerlink" title="3.Executors中的静态工厂方法"></a>3.Executors中的静态工厂方法</h5><p><img src="E:\图片\Typora\并发编程\image-20230921090327806.png" alt="image-20230921090327806"></p>
<h5 id="4-大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升"><a href="#4-大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升" class="headerlink" title="4.大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升"></a>4.大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升</h5><h3 id="取消和关闭"><a href="#取消和关闭" class="headerlink" title="取消和关闭"></a>取消和关闭</h3><h5 id="1-在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用"><a href="#1-在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用" class="headerlink" title="1.在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用"></a>1.在API和语言规范中，并没有把中断与任何取消的语意绑定起来，但是，实际上，使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的应用</h5><h5 id="2-调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息"><a href="#2-调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息" class="headerlink" title="2.调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息"></a>2.调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息</h5><h5 id="3-中断通常是实现取消最明智的选择"><a href="#3-中断通常是实现取消最明智的选择" class="headerlink" title="3.中断通常是实现取消最明智的选择"></a>3.中断通常是实现取消最明智的选择</h5><h5 id="4-因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么"><a href="#4-因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么" class="headerlink" title="4.因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么"></a>4.因为每一个线程都有其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么</h5><h5 id="5-只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求"><a href="#5-只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求" class="headerlink" title="5.只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求"></a>5.只有实现了线程中断策略的代码才可以接收中断请求。通用目的的任务和库的代码绝不应该接收中断请求</h5><h5 id="6-对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法"><a href="#6-对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法" class="headerlink" title="6.对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法"></a>6.对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法</h5><h5 id="7-在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中"><a href="#7-在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中" class="headerlink" title="7.在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中"></a>7.在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中</h5><h4 id="精灵线程"><a href="#精灵线程" class="headerlink" title="精灵线程"></a>精灵线程</h4><h5 id="8-线程被分为两种：普通线程和精灵线程（daemon-thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。"><a href="#8-线程被分为两种：普通线程和精灵线程（daemon-thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。" class="headerlink" title="8.线程被分为两种：普通线程和精灵线程（daemon thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。"></a>8.线程被分为两种：普通线程和精灵线程（daemon thread）。JVM启动时创建所有的线程，除了主线程以外，其他的都是精灵线程（比如垃圾回收器和其他类似线程）。当一个新的线程创建时，新线程继承了创建它的线程的后台状态，所以默认情况下，任何主线程创建的线程都是普通线程。</h5><h5 id="9-普通线程和精灵线程之间的差别仅仅在于退出时会发生什么"><a href="#9-普通线程和精灵线程之间的差别仅仅在于退出时会发生什么" class="headerlink" title="9.普通线程和精灵线程之间的差别仅仅在于退出时会发生什么"></a>9.普通线程和精灵线程之间的差别仅仅在于退出时会发生什么</h5><h5 id="10-应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理"><a href="#10-应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理" class="headerlink" title="10.应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理"></a>10.应用程序中，精灵线程不能替代对服务的生命周期恰当，。良好的管理</h5><h5 id="11-避免使用finalizer"><a href="#11-避免使用finalizer" class="headerlink" title="11.避免使用finalizer"></a>11.避免使用finalizer</h5><h3 id="应用线程池"><a href="#应用线程池" class="headerlink" title="应用线程池"></a>应用线程池</h3><h5 id="1-一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度"><a href="#1-一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度" class="headerlink" title="1.一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度"></a>1.一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会要求线程池足够大，来保证它所依赖任务不必排队或者不被拒绝，采用线程限制的任务需要顺序地执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度</h5><h5 id="2-无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档"><a href="#2-无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档" class="headerlink" title="2.无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档"></a>2.无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档</h5><h5 id="3-newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。"><a href="#3-newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。" class="headerlink" title="3.newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。"></a>3.newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。</h5><h5 id="4-当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的"><a href="#4-当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的" class="headerlink" title="4.当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的"></a>4.当每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果"><a href="#对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果" class="headerlink" title="对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果"></a>对于并发执行的任务，Executor框架是强大且灵活的。它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为，然而，和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作；一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能产生意外的结果</h5><h3 id="GUI应用程序"><a href="#GUI应用程序" class="headerlink" title="GUI应用程序"></a>GUI应用程序</h3><h5 id="1-Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求"><a href="#1-Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求" class="headerlink" title="1.Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求"></a>1.Swing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建，修改和请求</h5><h5 id="2-如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计"><a href="#2-如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计" class="headerlink" title="2.如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计"></a>2.如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时可以考虑运用分拆模型设计</h5><h5 id="3-GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持-x2F-无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发"><a href="#3-GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持-x2F-无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发" class="headerlink" title="3.GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持&#x2F;无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发"></a>3.GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。因为只要唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。像SwingWorker以及构建BackgroundTask这些助手类，提供了对取消、进度指示、完成指示的支持&#x2F;无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发</h5><h3 id="活跃度，性能和测试"><a href="#活跃度，性能和测试" class="headerlink" title="活跃度，性能和测试"></a>活跃度，性能和测试</h3><h4 id="避免活跃度危险"><a href="#避免活跃度危险" class="headerlink" title="避免活跃度危险"></a>避免活跃度危险</h4><h5 id="1-安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering-deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource-deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的"><a href="#1-安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering-deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource-deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的" class="headerlink" title="1.安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的"></a>1.安全性和活跃度通常相互牵制。我们使用锁开保证线程安全，但是滥用锁可能引起锁顺序死锁（lock-ordering deadlock）。类似的，我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的资源死锁（resource deadlock）。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值的</h5><h5 id="2-如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了"><a href="#2-如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了" class="headerlink" title="2.如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了"></a>2.如果所有线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了</h5><h5 id="3-在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程"><a href="#3-在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程" class="headerlink" title="3.在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程"></a>3.在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁（产生死锁的风险），或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程</h5><h5 id="4-当调用的方法不需要持有锁时，这被称为开放调用"><a href="#4-当调用的方法不需要持有锁时，这被称为开放调用" class="headerlink" title="4.当调用的方法不需要持有锁时，这被称为开放调用"></a>4.当调用的方法不需要持有锁时，这被称为开放调用</h5><h5 id="5-在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析"><a href="#5-在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析" class="headerlink" title="5.在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析"></a>5.在程序中尽量使用开发调用。依赖于开发调用程序，相比于那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度（deadlock-freedom）的分析</h5><h5 id="6-抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级"><a href="#6-抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级" class="headerlink" title="6.抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级"></a>6.抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用的优先级</h5><h5 id="7-可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I-x2F-O带宽），吞吐量和生产量能够相应地得以改进"><a href="#7-可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I-x2F-O带宽），吞吐量和生产量能够相应地得以改进" class="headerlink" title="7.可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I&#x2F;O带宽），吞吐量和生产量能够相应地得以改进"></a>7.可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I&#x2F;O带宽），吞吐量和生产量能够相应地得以改进</h5><h5 id="8-避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快"><a href="#8-避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快" class="headerlink" title="8.避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快"></a>8.避免不成熟的优化，首先使程序正确，然后再加快–如果它运行得还不够快</h5><h5 id="9-测评。不要臆测"><a href="#9-测评。不要臆测" class="headerlink" title="9.测评。不要臆测"></a>9.测评。不要臆测</h5><h5 id="10-所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧"><a href="#10-所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧" class="headerlink" title="10.所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧"></a>10.所有得并发程序都要一些串行源；如果你认为你没有，那么去仔细检查吧</h5><h5 id="11-不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化"><a href="#11-不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化" class="headerlink" title="11.不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化"></a>11.不要过分担心非竞争得同步带来的开销。基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化</h5><h5 id="12-串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性"><a href="#12-串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性" class="headerlink" title="12.串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性"></a>12.串行化会损害可伸缩性，上下文切换回损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性</h5><h5 id="13-并发程序中，对可伸缩性首要的威胁是独占的资源锁"><a href="#13-并发程序中，对可伸缩性首要的威胁是独占的资源锁" class="headerlink" title="13.并发程序中，对可伸缩性首要的威胁是独占的资源锁"></a>13.并发程序中，对可伸缩性首要的威胁是独占的资源锁</h5><h5 id="14-三种方式来减少锁的竞争"><a href="#14-三种方式来减少锁的竞争" class="headerlink" title="14.三种方式来减少锁的竞争"></a>14.三种方式来减少锁的竞争</h5><h5 id="1-减少持有锁的时间"><a href="#1-减少持有锁的时间" class="headerlink" title="1.减少持有锁的时间"></a>1.减少持有锁的时间</h5><h5 id="2-减少请求锁的频率"><a href="#2-减少请求锁的频率" class="headerlink" title="2.减少请求锁的频率"></a>2.减少请求锁的频率</h5><h5 id="3-或者用协调机制取代独占锁，从而允许更强的并发性"><a href="#3-或者用协调机制取代独占锁，从而允许更强的并发性" class="headerlink" title="3.或者用协调机制取代独占锁，从而允许更强的并发性"></a>3.或者用协调机制取代独占锁，从而允许更强的并发性</h5><h5 id="15-Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的"><a href="#15-Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的" class="headerlink" title="15.Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的"></a>15.Amdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的</h5><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h5 id="16-可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁"><a href="#16-可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁" class="headerlink" title="16.可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁"></a>16.可伸缩性通常可以通过以下这些方式提升：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占或非阻塞锁来取代独占锁</h5><h3 id="测试并发程序"><a href="#测试并发程序" class="headerlink" title="测试并发程序"></a>测试并发程序</h3><h5 id="1-为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。"><a href="#1-为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。" class="headerlink" title="1.为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。"></a>1.为并发类创建有效的安全测试，其挑战在于：如何在程序出现问题并导致某些属性极度可能失败时，简单地识别出这些检查的属性来，同时不要人为的让查找错误的代码限制住程序的并发性。最好能做到在检查测试的属性时，不需要任何的同步。</h5><h5 id="2-测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性"><a href="#2-测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性" class="headerlink" title="2.测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性"></a>2.测试应该在多处理器系统上运行，以提高潜在交替运行的多样性。但是，多个CPU未必会使测试更加高效，为了能够最大程度地检测到时序敏感的数据竞争的发生机会，应该让测试中的线程数多于CPU数，这样在任何给定的时间里，都要一些线程在运行，一些被交换出执行队列，这样可以增加线程间交替行为的随机性</h5><h5 id="3-编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式"><a href="#3-编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式" class="headerlink" title="3.编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式"></a>3.编写有效的性能测试，就需要哄骗优化器不要把你的基准测试当作死代码而优化掉。这需要每一个计算的结果都要应用在你的程序中–以一种不需要的同步或真实计算的方式</h5><h3 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h3><h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><h5 id="1-性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了"><a href="#1-性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了" class="headerlink" title="1.性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了"></a>1.性能是一个不断变化的目标，昨天的基准显示X比Y更快，这可能已经过时了</h5><h5 id="2-正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了"><a href="#2-正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了" class="headerlink" title="2.正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了"></a>2.正如默认的ReentrantLock一样，内部锁没有提供确定的公平性保证，但是大多数锁实现统计上的公平性保证，在大多数条件下已经足够好了，Java语言规范并没有要求JVM公平地实现内部锁，JVM也的确没有这样做。ReentrantLock并没有减少锁的公平性–它只不过使一些存在的部分更显性化了</h5><h5 id="3-在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized"><a href="#3-在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized" class="headerlink" title="3.在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized"></a>3.在内部锁不能够满足使用时，ReentrantLock才被作为更高级的工具。当你需要以下高级特性时，才应该使用；可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized</h5><h5 id="4-读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力"><a href="#4-读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力" class="headerlink" title="4.读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力"></a>4.读-写锁（ReadWriteLock）允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力</h5><h3 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h3><h5 id="1-条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系"><a href="#1-条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系" class="headerlink" title="1.条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系"></a>1.条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系</h5><h5 id="2-将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档"><a href="#2-将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档" class="headerlink" title="2.将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档"></a>2.将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档</h5><h5 id="3-每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量"><a href="#3-每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量" class="headerlink" title="3.每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量"></a>3.每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量</h5><h5 id="4-一个单独的内部条件队列可以与多个条件谓词共同使用"><a href="#4-一个单独的内部条件队列可以与多个条件谓词共同使用" class="headerlink" title="4.一个单独的内部条件队列可以与多个条件谓词共同使用"></a>4.一个单独的内部条件队列可以与多个条件谓词共同使用</h5><h5 id="5-当使用条件等待（Object-wait或者Condition。await）"><a href="#5-当使用条件等待（Object-wait或者Condition。await）" class="headerlink" title="5.当使用条件等待（Object.wait或者Condition。await）"></a>5.当使用条件等待（Object.wait或者Condition。await）</h5><h5 id="1-永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；"><a href="#1-永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；" class="headerlink" title="1.永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；"></a>1.永远设置一个条件谓词–一些对象状态的测试，线程执行前必须满足它；</h5><h5 id="2-永远在调用wait前测试条件谓词，并且从wait中返回后再次测试"><a href="#2-永远在调用wait前测试条件谓词，并且从wait中返回后再次测试" class="headerlink" title="2.永远在调用wait前测试条件谓词，并且从wait中返回后再次测试"></a>2.永远在调用wait前测试条件谓词，并且从wait中返回后再次测试</h5><h5 id="3-永远在循环中调用wait"><a href="#3-永远在循环中调用wait" class="headerlink" title="3.永远在循环中调用wait"></a>3.永远在循环中调用wait</h5><h5 id="4-确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；"><a href="#4-确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；" class="headerlink" title="4.确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；"></a>4.确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；</h5><h5 id="5-当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且"><a href="#5-当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且" class="headerlink" title="5.当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且"></a>5.当调用wait，notify或者notifyAll时，要持有与条件队列相关联的锁，并且</h5><h5 id="6-在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁"><a href="#6-在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁" class="headerlink" title="6.在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁"></a>6.在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁</h5><h5 id="7-无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你"><a href="#7-无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你" class="headerlink" title="7.无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你"></a>7.无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你</h5><h5 id="8-只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行"><a href="#8-只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行" class="headerlink" title="8.只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行"></a>8.只有同时满足下述条件后，才能用单一的notify取代notifyAll（一般使用notifyAll）：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回执行行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行</h5><h5 id="9-尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的"><a href="#9-尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的" class="headerlink" title="9.尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的"></a>9.尽管使用notifyAll而非notify可能有些低效，但是这样做更容易确保你的类的行为时正确的</h5><h5 id="10-一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中"><a href="#10-一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中" class="headerlink" title="10.一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中"></a>10.一个依赖于状态的类，要么完全将它的等待和通知协议暴露（并文档化）给子类，要么完全阻止子类参与其中</h5><h5 id="11-危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！"><a href="#11-危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！" class="headerlink" title="11.危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！"></a>11.危险警告：wait，notify和notifyAll在Condition对象中的对象对等体是await，signal和signalAll。但是，Condition继承Object，这意味着它也有wait和notify方法。一定要确保使用了正确的版本–await和signal！</h5><h3 id="原子变量与非阻塞同步机制"><a href="#原子变量与非阻塞同步机制" class="headerlink" title="原子变量与非阻塞同步机制"></a>原子变量与非阻塞同步机制</h3><h5 id="1-如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的"><a href="#1-如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的" class="headerlink" title="1.如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的"></a>1.如果能够避免的话，不共享状态的开销会更小。能够通过更有效地竞争改进可伸缩性，但是真正的可伸缩完全是通过减少竞争实现的</h5><h5 id="2-非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作"><a href="#2-非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作" class="headerlink" title="2.非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作"></a>2.非阻塞算法通过使用底层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当作“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作</h5><h5 id="3-非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。"><a href="#3-非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。" class="headerlink" title="3.非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。"></a>3.非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。</h5><h3 id="Java存储模型"><a href="#Java存储模型" class="headerlink" title="Java存储模型"></a>Java存储模型</h3><h5 id="1-happens-before的法则包括："><a href="#1-happens-before的法则包括：" class="headerlink" title="1.happens-before的法则包括："></a>1.happens-before的法则包括：</h5><h5 id="程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后"><a href="#程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后" class="headerlink" title="程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后"></a>程序次序法制：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后</h5><h5 id="监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。"><a href="#监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。" class="headerlink" title="监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。"></a>监视器锁法制：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。</h5><h5 id="volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。"><a href="#volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。" class="headerlink" title="volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。"></a>volatile变量法制：对volatile域的写入操作happens-before于每一个后续对同一域的读操作。</h5><h5 id="线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动程序中的动作"><a href="#线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动程序中的动作" class="headerlink" title="线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动程序中的动作"></a>线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动程序中的动作</h5><h5 id="线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动线程中的动作"><a href="#线程启动法制：在一个线程里，对Thread-start的调用会happens-before于每一个启动线程中的动作" class="headerlink" title="线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动线程中的动作"></a>线程启动法制：在一个线程里，对Thread.start的调用会happens-before于每一个启动线程中的动作</h5><h5 id="线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread-join调用中成功返回，或者Thread-isAlive返回false。"><a href="#线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread-join调用中成功返回，或者Thread-isAlive返回false。" class="headerlink" title="线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或者Thread.isAlive返回false。"></a>线程终结法制：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或者Thread.isAlive返回false。</h5><h5 id="中断法制：一个线程调用另一个线程的interrupt-happens-before-于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）"><a href="#中断法制：一个线程调用另一个线程的interrupt-happens-before-于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）" class="headerlink" title="中断法制：一个线程调用另一个线程的interrupt happens-before 于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）"></a>中断法制：一个线程调用另一个线程的interrupt happens-before 于被中断的线程发现中断（通过抛出InterruptedException，获知调用isInterrupted和interrupted）</h5><h5 id="终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。"><a href="#终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。" class="headerlink" title="终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。"></a>终结法制：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</h5><h5 id="传递性：如果A-happens-before于B，且B-happens-before-于C，则A-happens-before于C"><a href="#传递性：如果A-happens-before于B，且B-happens-before-于C，则A-happens-before于C" class="headerlink" title="传递性：如果A happens-before于B，且B happens-before 于C，则A happens-before于C"></a>传递性：如果A happens-before于B，且B happens-before 于C，则A happens-before于C</h5><h5 id="2-除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它"><a href="#2-除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它" class="headerlink" title="2.除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它"></a>2.除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布时happens-before于对象的消费线程使用它</h5><h5 id="3-初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。"><a href="#3-初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。" class="headerlink" title="3.初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。"></a>3.初始化安全可以保证，对于正确创建的对象，无论它如何发布的，所有线程都将看到构造函数设置的final域的值，更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量（比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容），也可以保证对其他线程都是可见的。</h5><h5 id="4-初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。"><a href="#4-初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。" class="headerlink" title="4.初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。"></a>4.初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过非final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。</h5><h3 id="同步Annotation"><a href="#同步Annotation" class="headerlink" title="同步Annotation"></a>同步Annotation</h3><h5 id="3个类级Annotation来描述类的可预期的线程安全性保证：-Immutable-，-ThreadSafe-和-NotThreadSafe"><a href="#3个类级Annotation来描述类的可预期的线程安全性保证：-Immutable-，-ThreadSafe-和-NotThreadSafe" class="headerlink" title="3个类级Annotation来描述类的可预期的线程安全性保证：@Immutable ，@ThreadSafe 和 @NotThreadSafe"></a>3个类级Annotation来描述类的可预期的线程安全性保证：@Immutable ，@ThreadSafe 和 @NotThreadSafe</h5><p><strong>@Immutable自然是意味着类是不可变的，并包含了@ThreadSafe的意义。@NotThreadSafe是可选的–如果类没有被标明是线程安全的，就无法肯定它是不是线程安全的，但是如果你想明确地表示出它不是线程安全的，就标注为@NotThreadSafe</strong></p>
<p><strong>这些Annotation相对是非侵入的，这对用户和维护者都是有益的。用户可以立即看出一个类是否线程安全的，维护者也可以直接检查是否遵循了线程安全性保证。Annotation对于第三个利益既得者也是有用的：工具。静态的代码分析工具可以有能力对代码进行验证，看它是否遵循了由Annotation指定的契约，比如标明为@Immutable的类是否真是不可变的</strong></p>
]]></content>
  </entry>
  <entry>
    <title>并发编程艺术</title>
    <url>/2024/10/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h5 id="1-如何减少上下文切换"><a href="#1-如何减少上下文切换" class="headerlink" title="1.如何减少上下文切换"></a>1.如何减少上下文切换</h5><p>减少上下文切换的方法有无锁并发编程，CAS算法，使用最少线程和使用协程</p>
<h5 id="2-如何解决资源限制的问题"><a href="#2-如何解决资源限制的问题" class="headerlink" title="2.如何解决资源限制的问题"></a>2.如何解决资源限制的问题</h5><p>对于硬件资源限制，可以考虑使用集群并行执行程序，既然单机的资源有限制，那么就让程序在多机上运行，比如使用ODPS，Hadoop或者自己搭建服务器集群，不同的机器处理不同的数据。可以通过“数据ID%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。</p>
<p>对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接</p>
<h5 id="3-volatile的两条实现原则"><a href="#3-volatile的两条实现原则" class="headerlink" title="3.volatile的两条实现原则"></a>3.volatile的两条实现原则</h5><p>1.Lock前缀指令会引起处理器缓存回写到内存</p>
<p>2.一个处理器的缓存回写到内存会导致其他处理器的缓存无效</p>
<h5 id="4-处理器如何实现原子操作"><a href="#4-处理器如何实现原子操作" class="headerlink" title="4.处理器如何实现原子操作"></a>4.处理器如何实现原子操作</h5><p>1.第一个机制时通过总线锁保证原子性</p>
<p>2.第二个机制是通过缓存锁定来保证原子性</p>
<p>但是有两种情况下处理器不会使用缓存锁定</p>
<p>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定</p>
<p>第二种情况是：有些处理器不支持缓存锁定。</p>
<h5 id="5-CAS实现原子操作的三大问题"><a href="#5-CAS实现原子操作的三大问题" class="headerlink" title="5.CAS实现原子操作的三大问题"></a>5.CAS实现原子操作的三大问题</h5><p>1.ABA问题</p>
<p>2.循环时间长开销大</p>
<p>3.只能保证一个共享变量的原子操作</p>
<h5 id="6-在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信时指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递"><a href="#6-在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信时指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递" class="headerlink" title="6.在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信时指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递"></a>6.在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信时指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递</h5><h5 id="7-Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序原完全透明。"><a href="#7-Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序原完全透明。" class="headerlink" title="7.Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序原完全透明。"></a>7.Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序原完全透明。</h5><h5 id="8-happens-before规则"><a href="#8-happens-before规则" class="headerlink" title="8.happens-before规则"></a>8.happens-before规则</h5><p>1.程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作</p>
<p>2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁</p>
<p>3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<p>4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C</p>
<h5 id="9-未同步程序的执行特性"><a href="#9-未同步程序的执行特性" class="headerlink" title="9.未同步程序的执行特性"></a>9.未同步程序的执行特性</h5><p><strong>差异</strong></p>
<p>1.顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</p>
<p>2.顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</p>
<p>3.JMM不保证64位long型和double型的变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读&#x2F;写操作都具有原子性。</p>
<h5 id="10-由于Java的CAS同时具有volatile读和volatile写的内存语义因此Java线程之间的通信现在有了下面4种方式"><a href="#10-由于Java的CAS同时具有volatile读和volatile写的内存语义因此Java线程之间的通信现在有了下面4种方式" class="headerlink" title="10.由于Java的CAS同时具有volatile读和volatile写的内存语义因此Java线程之间的通信现在有了下面4种方式"></a>10.由于Java的CAS同时具有volatile读和volatile写的内存语义因此Java线程之间的通信现在有了下面4种方式</h5><p>1.A线程写volatile变量，随后B线程读这个volatile变量</p>
<p>2.A线程写volatile变量，随后B线程用CAS更新这个volatile变量</p>
<p>3.A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量</p>
<p>4.A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量</p>
<h5 id="11-对于final，编译器和处理器要遵守两个重排序规则"><a href="#11-对于final，编译器和处理器要遵守两个重排序规则" class="headerlink" title="11.对于final，编译器和处理器要遵守两个重排序规则"></a>11.对于final，编译器和处理器要遵守两个重排序规则</h5><p>1.在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</p>
<p>2.初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序</p>
<h5 id="12-线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定"><a href="#12-线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定" class="headerlink" title="12.线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定"></a>12.线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定</h5><h5 id="13-锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程"><a href="#13-锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程" class="headerlink" title="13.锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程"></a>13.锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程</h5><h5 id="14-合理地使用线程池能够带来3个好处"><a href="#14-合理地使用线程池能够带来3个好处" class="headerlink" title="14.合理地使用线程池能够带来3个好处"></a>14.合理地使用线程池能够带来3个好处</h5><p>第一，降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗</p>
<p>第二，提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行</p>
<p>第三，提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配，调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p>
<h5 id="15-在并发编程中使用生产者和消费者模式能够解决大多数并发问题。该模式通过平衡生产者和消费者的工作能力来提高程序整体处理数据的速度"><a href="#15-在并发编程中使用生产者和消费者模式能够解决大多数并发问题。该模式通过平衡生产者和消费者的工作能力来提高程序整体处理数据的速度" class="headerlink" title="15.在并发编程中使用生产者和消费者模式能够解决大多数并发问题。该模式通过平衡生产者和消费者的工作能力来提高程序整体处理数据的速度"></a>15.在并发编程中使用生产者和消费者模式能够解决大多数并发问题。该模式通过平衡生产者和消费者的工作能力来提高程序整体处理数据的速度</h5>]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>1.针对接口编程，而不是针对实现编程</p>
<p>2.”针对接口编程“真正的意思是“针对超类型（supertype）编程”</p>
<p>3.多用组合少用继承</p>
<p>4.为了交互对象之间的松耦合设计而努力</p>
<p>5.类应该对扩展开放，对修改关闭</p>
<p>6.要依赖抽象，不要依赖具体类（依赖倒置原则）</p>
<p>7.最少知识原则：只和你的密友谈话</p>
<p>8.别调用我们，我们会调用你</p>
<p>9.一个类应该只有一个引起变化的原因</p>
<h3 id="松耦合的威力"><a href="#松耦合的威力" class="headerlink" title="松耦合的威力"></a>松耦合的威力</h3><p><strong>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节，观察者模式提供了一种对象设计，让主题和观察者之间松耦合</strong></p>
<p><strong>松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降低了最低</strong></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</strong></p>
<p><strong>要点</strong></p>
<p>1.策略模式通常会用行为或算法配置Context类</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者会收到通知并自动更新</strong></p>
<p><strong>要点</strong></p>
<p>1.观察者模式定义了对象之间一对多的关系</p>
<p>2.主题（也就是可观察者）用一个共同的接口来更新观察者</p>
<p>3.观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口</p>
<p>4.使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）。</p>
<p>5.有多个观察者时，不可以依赖特定的通知次序</p>
<p>6.Java有多种观察者模式的实现，包括了通用的java.util.Observable实现上所带来的一些问题</p>
<p>7.如果有必要的话，可以实现自己的Observable，这并不难，不要害怕</p>
<p>8.Swing大量使用观察者模式，许多GUI框架也是如此</p>
<p>9.此模式也被应用在许多地方，例如：JavaBeans，RMI</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p><strong>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案</strong></p>
<p><strong>装饰者和被装饰对象有相同的超类型</strong></p>
<p><strong>你可以用一个或多个装饰者包装一个对象</strong></p>
<p><strong>既然装饰者和被装饰者有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它</strong></p>
<p><strong>装饰者可以在所委托被装饰者的行为之前与&#x2F;或之后，加上自己的行为，以达到特定的目的</strong></p>
<p><strong>对象可以在任何时候被装饰，所以可以在运行时动态地，不限量地用你喜欢的装饰者来装饰对象</strong></p>
<p><strong>要点</strong></p>
<p>1.继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式</p>
<p>2.在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码</p>
<p>3.组合和委托可用与在运行时动态地加上新的行为</p>
<p>4.除了继承装饰者模式也可以让我们扩展行为</p>
<p>5.装饰者模式意味着一群装饰者类，这些类用来包装具体组件</p>
<p>6.装饰者类放映处被装饰的组件类型（事实上，它们具有相同的类型，都经过接口或继承实现）</p>
<p>7.装饰者可以在被装饰者的行为前面与&#x2F;或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的</p>
<p>8.你可以用无数个装饰者包装一个组件</p>
<p>9.装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型</p>
<p>10.装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂</p>
<h3 id="简单工厂方法模式"><a href="#简单工厂方法模式" class="headerlink" title="简单工厂方法模式"></a>简单工厂方法模式</h3><p><strong>定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类</strong></p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><strong>避免违反</strong></p>
<p>1.变量不可以持有具体类的引用   （如果使用new，就会持有具体类的引用。你可以改用工厂避开这样的做法）</p>
<p>2.不要让类派生自具体类   （如果派生自具体类，你就会依赖具体类，请派生自一个抽象[接口或抽象类]）</p>
<p>3.不要覆盖基类中已实现的方法   （如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</p>
<p><strong>要点</strong></p>
<p>1.简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦</p>
<p>2.工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象</p>
<p>3.工厂方法允许类将实例化延迟到子类进行</p>
<p>4.工厂是很有威力的技巧，帮助外面针对抽象编程，而不要针对具体类编程</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</strong></p>
<p><strong>要点</strong></p>
<p>1.所有的工厂都是用来封装对象的创建</p>
<p>2.抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中</p>
<p>3.所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</p>
<p>4.抽象工厂创建相关的对象家族，而不需要依赖它们的具体类</p>
<p>5.依赖倒置原则，指导外面避免依赖具体类型，而要尽量依赖抽象</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>确保一个类只有一个实例，并提供一个全局访问的</strong></p>
<p><strong>要点</strong></p>
<p>1.单例模式确保程序中一个类最多只有一个实例</p>
<p>2.单例模式也提供访问这个实例的全局点</p>
<p>3.在Java中实现单例模式需要私有的构造器，一个静态方法和一个静态变量</p>
<p>4.确定在性能和资源上的限制，然后小心地选择适当的方案来实现单例，以解决多线程的问题（我们必须认定所有的程序都是多线程的）</p>
<p>5.小心，你如果使用多个类加载器，可能导致单例失效而产生多个实例</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><strong>将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作</strong></p>
<p><strong>要点</strong></p>
<p>1.命令模式将发出请求的对象和执行请求的对象解耦</p>
<p>2.在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作</p>
<p>3.通用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用</p>
<p>4.调用者可以接受命令当做参数，甚至在运行时动态地进行</p>
<p>5.命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态</p>
<p>6.宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销</p>
<p>7.实际操作时，很常见使用“聪明”命令对象，也就是之间实现了请求，而不是将工作委托给接收者</p>
<p>8.命令也可以用来实现日志和事务系统</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间</strong></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用</strong></p>
<p><strong>要点</strong></p>
<p>1.当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器</p>
<p>2.当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观</p>
<p>3.适配器改变接口以符合客户的期望</p>
<p>4.外观将客户从一个复杂的子系统中解耦</p>
<p>5.实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定</p>
<p>6.实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行</p>
<p>7.适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承</p>
<p>8.你可以为一个子系统实现一个以上的外观</p>
<p>9.适配器将一个对象包装起来以改变其接口，装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><strong>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤</strong></p>
<p><strong>要点</strong></p>
<p>1.”模板方法”定义了算法的步骤，把这些步骤的实现延迟到子类</p>
<p>2.模板方法模式为我们提供了一种代码复用的重要技巧</p>
<p>3.模板方法的抽象类可以定义具体方法，抽象方法和钩子</p>
<p>4.抽象方法由子类实现</p>
<p>5.钩子是一种方法，它在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它</p>
<p>6.为了防止子类改变模板方法中的算法，可以将模板方法声明为final</p>
<p>7.好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用底层模块</p>
<p>8.你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的</p>
<p>9.策略模式和模板方法模式都封装算法，一个用组合，一个用继承</p>
<p>10.工厂方法是模板方法的一种特殊版本</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</strong></p>
<p><strong>迭代器模式让我们能游走于聚合内的每一个元素，而不暴露其内部的表示</strong></p>
<p><strong>把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所</strong></p>
<p><strong>要点</strong></p>
<p>1.迭代器允许访问聚合的元素，而不需要暴露它的内部结构</p>
<p>2.迭代器将遍历聚合的工作封装进一个对象中</p>
<p>3.当使用迭代器的时候，我们依赖聚合提供遍历</p>
<p>4.迭代器提供一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态</p>
<p>5.我们应该努力让一个类只分配一个责任</p>
<h3 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h3><p><strong>类的每个责任都有改变的潜在区域。超过一个责任，意味者超过一个改变的区域</strong></p>
<p><strong>这个原则告诉我们，尽量让每个类保持单一责任</strong></p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><strong>允许你将对象组合成树型结构来表现“整体&#x2F;部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</strong></p>
<p><strong>组合模式让我们能用树形创建对象的结构，树里面包含了组合以及个别的对象</strong>**</p>
<p><strong>使用组合结构，我们能把相同的操作应用在组合和个别对象上，换句话说，在大多数情况下，我们可以忽略组合和个别对象之间的差别</strong></p>
<p><strong>要点</strong></p>
<p>1.组合模式提供一个结构，可同时包容个别对象和组合对象</p>
<p>2.组合模式允许客户对个别对象以及组合对象一视同仁</p>
<p>3.组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点</p>
<p>4.在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性和安全性</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p><strong>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</strong></p>
<p> <strong>要点</strong></p>
<p>1.状态模式允许一个对象基于内部状态而拥有不同得行为</p>
<p>2.和程序状态机（PSM）不同，状态模式用类代表状态</p>
<p>3.Context会将行为委托给当前状态对象</p>
<p>4.通过将每个状态封装进一个类，我们把以后需要做得任何改变局部化了</p>
<p>5.状态模式和策略模式有相同的类图，但是它们的意图不同</p>
<p>6..状态模式允许Context随着状态的改变而改变行为</p>
<p>7.状态转换可以由State类或Context类控制</p>
<p>8.使用状态模式通常会导致设计中类的数目大量增加</p>
<p>9.状态类可以被多个Context实例共享</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>为另一个对象提供一个替身或占位符以控制对这个对象的访问</strong></p>
<p><strong>使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问被代理的对象可以是远程的对象，创建开销打的对象或需要安全的控制对象</strong></p>
<p><strong>要点</strong></p>
<p>1.代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种</p>
<p>2.远程代理管理客户和远程对象之间的交互</p>
<p>3.虚拟代理控制访问实例化开销大的对象</p>
<p>4.保护代理基于调用者控制对象方法的访问</p>
<p>5.代理模式有许多变体，例如：缓存代理，同步代理，防火墙代理和写入时复制代理</p>
<p>6.代理在结构上类似装饰者，但是目的不同</p>
<p>7.装饰者模式为对象加上行为，而代理则是控制访问</p>
<p>8.Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器</p>
<p>9.就和其他的包装者（wrapper）一样，代理会造成你的设计中类的数目增加</p>
<h3 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h3><p><strong>要点</strong></p>
<p>1.MVC是复合模式，结合了观察者模式，策略模式和组合模式</p>
<p>2.模型使用观察者模式，以便观察者更新，同时保持两者之间解耦</p>
<p>3.控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为</p>
<p>4.视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板，框架和按钮</p>
<p>5.这些模式携手合作，把MVC模型的三层解耦，这样可以保持设计干净又有弹性</p>
<p>6.适配器模式用来将新的模型适配成已有的视图和控制器</p>
<p>7.Model2是MVC在Web上的应用</p>
<p>8.在Model2中，控制器实现成Serblet，而JSP&#x2F;HTML实现视图</p>
<h3 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h3><p><strong>告诉你如何采用一个不好的解决方案解决一个问题</strong></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><strong>使用桥接模式（Bridge Pattern）不只改变你的实现，也改变你的抽象</strong></p>
<p><strong>桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变</strong></p>
<p><strong>适合使用在需要跨越多个平台的图形和窗口系统上</strong></p>
<p><strong>当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用</strong></p>
<p><strong>优点</strong></p>
<p>1.将实现予以解耦，让它和界面之间不再永久绑定</p>
<p>2.抽象和实现可以独立扩展，不会影响到对方</p>
<p>3.对于“具体的抽象类”所做的改变，不会影响到客户</p>
<p><strong>缺点</strong></p>
<p>桥接模式的缺点是增加了复杂度</p>
<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p><strong>使用生成器模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造</strong></p>
<p><strong>经常被用来创建组合结构</strong></p>
<p><strong>优点</strong></p>
<p>1.将一个复杂对象的创建过程封装起来</p>
<p>2.允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）</p>
<p>3.向客户隐藏产品内部的表现</p>
<p>4.产品的实现可以被替换，因为客户只看到一个对象的接口</p>
<p><strong>缺点</strong></p>
<p>与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><strong>当你想要让一个以上的对象有机会能够处理某个请求对象的时候，就使用责任链模式（Chain of Responsibility Pattern）</strong></p>
<p><strong>经常被使用在窗口系统中，处理鼠标和键盘之类的事件</strong></p>
<p><strong>优点</strong></p>
<p>将请求的发送者和接收者解耦</p>
<p>可以简化你的对象，因为它不需要知道链的结构</p>
<p>通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任</p>
<p><strong>缺点</strong></p>
<p>并不保证请求一定会被执行，如果没有任何对象处理它的话，它可能会落到链尾端之外（<strong>这可以是优点也可以是缺点</strong>）</p>
<p>可能不容易观察运行时的特征，有碍于出错</p>
<h3 id="蝇量模式"><a href="#蝇量模式" class="headerlink" title="蝇量模式"></a>蝇量模式</h3><p><strong>如果让某个类的一个实例能够用来提供许多“虚拟实例”，就使用蝇量模式（Flyweight Pattern）</strong></p>
<p><strong>当一个类有许多的实例，而这些实例能被同一方法控制的时候，我们就可以使用蝇量模式</strong></p>
<p><strong>优点</strong></p>
<p>减少运行时对象实例的个数，节省内存</p>
<p>将许多“虚拟”对象的状态集中管理</p>
<p><strong>缺点</strong></p>
<p>一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为</p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><strong>使用解释器模式（Interpreter Pattern）为语言创建解释器</strong></p>
<p><strong>当你需要实现一个简单的语言时，使用解释器</strong></p>
<p><strong>当你有一个简单的语法，而且简单比效率更重要时，使用解释器</strong></p>
<p><strong>可以处理脚本语言和编程语言</strong></p>
<p><strong>优点</strong></p>
<p>将每一个语法规则表示成一个类，方便于实现语言</p>
<p>因为语法由许多类表示，所以你可以轻易地改变或扩展此语言</p>
<p>通过在类结构中加入新的方法，可以在解释的同时增加新的行为，例如打印格式的美化或者进行复杂的程序验证</p>
<p><strong>缺点</strong></p>
<p>当语法规则的数目太大时，这个模式可能会变得非常繁杂。在这种情况下，使用解析器或编译器的产生器可能更加合适</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><strong>使用中介者模式（Mediator Pattern）来集中相关对象之间复杂的沟通和控制方式</strong></p>
<p><strong>中介者常常被用来协调相关的GUI组件</strong></p>
<p><strong>优点</strong></p>
<p>通过将对象彼此解耦，可以增加对象的复用性</p>
<p>通过将控制逻辑集中，可以简化系统维护</p>
<p>可以让对象之间所传递的消息变得简单而且大幅减少</p>
<p><strong>缺点</strong></p>
<p>中介者模式的缺点是，如果设计不当，中介者对象本身会变得过于复杂</p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p><strong>当你需要让对象返回之前的状态时（例如，你的用户请求“撤销”），就使用备忘录模式（MementoPattern）</strong></p>
<p><strong>备忘录用于储存状态</strong></p>
<p><strong>目的</strong></p>
<p>储存系统关键对象的重要状态</p>
<p>维护关键对象的封装</p>
<p><strong>优点</strong></p>
<p>将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚</p>
<p>保持关键对象的数据封装</p>
<p>提供了容易实现的恢复能力</p>
<p><strong>缺点</strong></p>
<p>储存和恢复状态的过程可能相当耗时</p>
<p>在Java系统时，其实可以考虑使用序列化（serialization）机制储存系统的状态</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>当创建给定类的实例的过程很复杂时，就使用原型模式（Prototype Pattern）</strong></p>
<p><strong>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型</strong></p>
<p><strong>优点</strong></p>
<p>向客户隐藏制造新实例的复杂性</p>
<p>提供让客户能够产生未知类型对象的选项</p>
<p>在某些环境下，复制对象比创建新对象更有效</p>
<p><strong>缺点</strong></p>
<p>对象的复制有时相当复杂</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p><strong>当你想要成为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式（Visitor Pattern）</strong></p>
<p><strong>当采用访问者模式的时候，就会打破组合类的封装</strong></p>
<p><strong>优点</strong></p>
<p>允许你对组合结构加入新的操作，而无需改变结构本身</p>
<p>想要加入新的操作，相对容易</p>
<p>访问者所进行的操作，其代码是集中在一起的</p>
<p><strong>缺点</strong></p>
<p>因为游走的功能牵涉其中，所以对组合结构的改变就更加困难</p>
<h3 id="定义设计模式"><a href="#定义设计模式" class="headerlink" title="定义设计模式"></a>定义设计模式</h3><p><strong>模式是在某情景（context）下，针对某问题的某种解决方案</strong></p>
<p><strong>情境</strong>就是应用某个模式的情况。这应该是会不断出现的情况</p>
<p><strong>问题</strong>就是你想在某情境下达到的目标，但也可以是某情境下的约束</p>
<p><strong>解决方案</strong>就是你所追求的：一个通用的设计，用来解决约束，达到目标</p>
<p><strong>如果你发现自己处于某个情境下，面对这所欲达到的目标被一群约束影响着的问题，然而，你能够应用某个设计，克服这些约束并达到该目标，将你领向某个解决方案</strong></p>
<p><strong>要点</strong></p>
<p>1.让设计模式自然而然地出现在你的设计中，而不是为了使用而使用</p>
<p>2.设计模式并非僵化的教条，你可以依据自己的需要采用或调整</p>
<p>3.总是使用满足需要的最简单解决方案，不管它用不用模式</p>
<p>4.学习设计模式的类目，可以帮你自己熟悉这些模式以及它们之间的关系</p>
<p>5.模式的分类（或类目）是将模式分成不用的族群，如果这么做对你有帮助，就采用吧</p>
<p>6.你必须相当专注才能够成为一个模式的作家，这需要时间也需要耐心，同时还必须乐意做大量的精化工作</p>
<p>7.请牢记：你所遇到大多数的模式都是现有模式的变体，而非新的模式</p>
<p>8.模式能够为你带来的最大好处之一是，让你的团队拥有共享词汇</p>
<p>9.任何社群都有自己的行话，模式社群也是如此。别让这些行话绊着，在读完这本书之后，你已经能够应用大部分的行话了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>装饰者</td>
<td>包装一个对象，以提供新的行为</td>
</tr>
<tr>
<td>状态</td>
<td>封装了基于状态的行为，并使用委托在行为之间切换</td>
</tr>
<tr>
<td>迭代器</td>
<td>在对象的集合之中游走，而不暴露集合的实现</td>
</tr>
<tr>
<td>外观</td>
<td>简化一群类的接口</td>
</tr>
<tr>
<td>策略</td>
<td>封装可以互换的行为，并使用委托来决定要使用哪一个</td>
</tr>
<tr>
<td>代理</td>
<td>包装对象，以控制对此对象的访问</td>
</tr>
<tr>
<td>工厂方法</td>
<td>由子类决定要创建的具体类是哪一个</td>
</tr>
<tr>
<td>适配器</td>
<td>封装对象，并提供不同的接口</td>
</tr>
<tr>
<td>观察者</td>
<td>让对象能够在状态改变时被通知</td>
</tr>
<tr>
<td>模板方法</td>
<td>客户用一致的方式处理对象集合和单个对象</td>
</tr>
<tr>
<td>组合</td>
<td>客户用一致的方式处理对象集合和单个对象</td>
</tr>
<tr>
<td>单件（单例）</td>
<td>确保有且只有一个对象被创建</td>
</tr>
<tr>
<td>抽象工厂</td>
<td>允许客户创建对象的家族，而无需指定他们的具体类</td>
</tr>
<tr>
<td>命令</td>
<td>封装请求成为对象</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计</title>
    <url>/2024/10/11/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="第一章，重构，第一个案例"><a href="#第一章，重构，第一个案例" class="headerlink" title="第一章，重构，第一个案例"></a>第一章，重构，第一个案例</h3><h5 id="1-如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构哪个程序，使特性的添加比较容易进行，然后再添加特性"><a href="#1-如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构哪个程序，使特性的添加比较容易进行，然后再添加特性" class="headerlink" title="1.如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构哪个程序，使特性的添加比较容易进行，然后再添加特性"></a>1.如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构哪个程序，使特性的添加比较容易进行，然后再添加特性</h5><h5 id="2-重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力"><a href="#2-重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力" class="headerlink" title="2.重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力"></a>2.重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力</h5><h5 id="3-重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它。"><a href="#3-重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它。" class="headerlink" title="3.重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它。"></a>3.重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它。</h5><h5 id="4-任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，-才是优秀的程序员"><a href="#4-任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，-才是优秀的程序员" class="headerlink" title="4.任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码， 才是优秀的程序员"></a>4.任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码， 才是优秀的程序员</h5><h3 id="第二章，重构原则"><a href="#第二章，重构原则" class="headerlink" title="第二章，重构原则"></a>第二章，重构原则</h3><h5 id="重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。"><a href="#重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。" class="headerlink" title="重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。"></a>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</h5><h5 id="重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构"><a href="#重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构" class="headerlink" title="重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构"></a>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构</h5><h5 id="1-事不过三，三则重构"><a href="#1-事不过三，三则重构" class="headerlink" title="1.事不过三，三则重构"></a>1.事不过三，三则重构</h5><h5 id="2-不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅"><a href="#2-不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅" class="headerlink" title="2.不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅"></a>2.不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅</h5><h3 id="第三章，代码的坏味道"><a href="#第三章，代码的坏味道" class="headerlink" title="第三章，代码的坏味道"></a>第三章，代码的坏味道</h3><h5 id="1-当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余"><a href="#1-当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余" class="headerlink" title="1.当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余"></a>1.当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余</h5><h3 id="第四章，构筑测试体系"><a href="#第四章，构筑测试体系" class="headerlink" title="第四章，构筑测试体系"></a>第四章，构筑测试体系</h3><h5 id="1-确保所有测试都完全自动化，让它们检查自己的测试结果"><a href="#1-确保所有测试都完全自动化，让它们检查自己的测试结果" class="headerlink" title="1.确保所有测试都完全自动化，让它们检查自己的测试结果"></a>1.确保所有测试都完全自动化，让它们检查自己的测试结果</h5><h5 id="2-一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的空间"><a href="#2-一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的空间" class="headerlink" title="2.一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的空间"></a>2.一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的空间</h5><h5 id="3-频繁地运行测试。每次编译请把测试也考虑进去–每天至少执行每个测试一次"><a href="#3-频繁地运行测试。每次编译请把测试也考虑进去–每天至少执行每个测试一次" class="headerlink" title="3.频繁地运行测试。每次编译请把测试也考虑进去–每天至少执行每个测试一次"></a>3.频繁地运行测试。每次编译请把测试也考虑进去–每天至少执行每个测试一次</h5><h5 id="4-每当你收到bug报告，请先写一个单元测试来暴露bug"><a href="#4-每当你收到bug报告，请先写一个单元测试来暴露bug" class="headerlink" title="4.每当你收到bug报告，请先写一个单元测试来暴露bug"></a>4.每当你收到bug报告，请先写一个单元测试来暴露bug</h5><h5 id="5-编写未臻完善的测试并实际运行，好过对完美测试的无尽等待"><a href="#5-编写未臻完善的测试并实际运行，好过对完美测试的无尽等待" class="headerlink" title="5.编写未臻完善的测试并实际运行，好过对完美测试的无尽等待"></a>5.编写未臻完善的测试并实际运行，好过对完美测试的无尽等待</h5><h5 id="6-考虑可能出错的边界条件，把测试火力集中在哪儿"><a href="#6-考虑可能出错的边界条件，把测试火力集中在哪儿" class="headerlink" title="6.考虑可能出错的边界条件，把测试火力集中在哪儿"></a>6.考虑可能出错的边界条件，把测试火力集中在哪儿</h5><h5 id="7-当事情被认为应该会出错时，别忘记了检查是否抛出了预期的异常"><a href="#7-当事情被认为应该会出错时，别忘记了检查是否抛出了预期的异常" class="headerlink" title="7.当事情被认为应该会出错时，别忘记了检查是否抛出了预期的异常"></a>7.当事情被认为应该会出错时，别忘记了检查是否抛出了预期的异常</h5><h5 id="8-不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug"><a href="#8-不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug" class="headerlink" title="8.不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug"></a>8.不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug</h5><h3 id="第八章，重新组织数据"><a href="#第八章，重新组织数据" class="headerlink" title="第八章，重新组织数据"></a>第八章，重新组织数据</h3><h5 id="检查重构目标是否为不可变对象，或是否可修改为不可变对象"><a href="#检查重构目标是否为不可变对象，或是否可修改为不可变对象" class="headerlink" title="检查重构目标是否为不可变对象，或是否可修改为不可变对象"></a>检查重构目标是否为不可变对象，或是否可修改为不可变对象</h5><p>如果该对象目前还不是不可变的，就使用Remove Setting Method（300），直到它成为不可变的为止</p>
<p>如果无法将该对象修改为不可变的，就放弃使用本项重构</p>
<h5 id="建立equals（）和hashCode（）"><a href="#建立equals（）和hashCode（）" class="headerlink" title="建立equals（）和hashCode（）"></a>建立equals（）和hashCode（）</h5><h5 id="编译，测试"><a href="#编译，测试" class="headerlink" title="编译，测试"></a>编译，测试</h5><h5 id="考虑是否可以删除工厂函数，并将构造函数声明为pubilc"><a href="#考虑是否可以删除工厂函数，并将构造函数声明为pubilc" class="headerlink" title="考虑是否可以删除工厂函数，并将构造函数声明为pubilc"></a>考虑是否可以删除工厂函数，并将构造函数声明为pubilc</h5><h5 id="一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点"><a href="#一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点" class="headerlink" title="一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点"></a>一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。之所以这样做，原因有以下几点</h5><p>1，你可能需要使用不同的用户界面来表现相同的业务逻辑，如果同时承担两种责任，用户界面会变得过于复杂，2，与GUI隔离之后，领域对象的维护和演化都会更容易，你甚至可以让不同的开发者负责不同部分的开发</p>
<h3 id="第九章，简化条件表达式"><a href="#第九章，简化条件表达式" class="headerlink" title="第九章，简化条件表达式"></a>第九章，简化条件表达式</h3><h5 id="1-从if，then，else三个段落中分别提炼出独立函数"><a href="#1-从if，then，else三个段落中分别提炼出独立函数" class="headerlink" title="1.从if，then，else三个段落中分别提炼出独立函数"></a>1.从if，then，else三个段落中分别提炼出独立函数</h5><h5 id="2-将测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数"><a href="#2-将测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数" class="headerlink" title="2.将测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数"></a>2.将测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数</h5><h5 id="3-将重复代码搬到条件表达式之外"><a href="#3-将重复代码搬到条件表达式之外" class="headerlink" title="3.将重复代码搬到条件表达式之外"></a>3.将重复代码搬到条件表达式之外</h5><h5 id="4-以break语句或return语句取代控制标记"><a href="#4-以break语句或return语句取代控制标记" class="headerlink" title="4.以break语句或return语句取代控制标记"></a>4.以break语句或return语句取代控制标记</h5><h5 id="5-使用卫语句表现所有特殊情况"><a href="#5-使用卫语句表现所有特殊情况" class="headerlink" title="5.使用卫语句表现所有特殊情况"></a>5.使用卫语句表现所有特殊情况</h5><h5 id="6-将条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数"><a href="#6-将条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数" class="headerlink" title="6.将条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数"></a>6.将条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</h5><h5 id="7-将null值替换为null对象"><a href="#7-将null值替换为null对象" class="headerlink" title="7.将null值替换为null对象"></a>7.将null值替换为null对象</h5><h5 id="8-以断言明确表现这种假设"><a href="#8-以断言明确表现这种假设" class="headerlink" title="8.以断言明确表现这种假设"></a>8.以断言明确表现这种假设</h5><h3 id="第十章，简化函数调用"><a href="#第十章，简化函数调用" class="headerlink" title="第十章，简化函数调用"></a>第十章，简化函数调用</h3><h5 id="1-修改函数名称"><a href="#1-修改函数名称" class="headerlink" title="1.修改函数名称"></a>1.修改函数名称</h5><h5 id="2-为函数添加一个对象参数，让该对象带进函数所需信息"><a href="#2-为函数添加一个对象参数，让该对象带进函数所需信息" class="headerlink" title="2.为函数添加一个对象参数，让该对象带进函数所需信息"></a>2.为函数添加一个对象参数，让该对象带进函数所需信息</h5><h5 id="3-移除不必要的参数"><a href="#3-移除不必要的参数" class="headerlink" title="3.移除不必要的参数"></a>3.移除不必要的参数</h5><h5 id="4-将查询函数和修改函数分离"><a href="#4-将查询函数和修改函数分离" class="headerlink" title="4.将查询函数和修改函数分离"></a>4.将查询函数和修改函数分离</h5><h5 id="5-建立单一函数，以参数表示那些不同的值"><a href="#5-建立单一函数，以参数表示那些不同的值" class="headerlink" title="5.建立单一函数，以参数表示那些不同的值"></a>5.建立单一函数，以参数表示那些不同的值</h5><h5 id="6-以明确函数取代参数"><a href="#6-以明确函数取代参数" class="headerlink" title="6.以明确函数取代参数"></a>6.以明确函数取代参数</h5><h5 id="7-保持对象完整"><a href="#7-保持对象完整" class="headerlink" title="7.保持对象完整"></a>7.保持对象完整</h5><h5 id="8-让参数接受者去除该项参数，并直接调用前一个函数"><a href="#8-让参数接受者去除该项参数，并直接调用前一个函数" class="headerlink" title="8.让参数接受者去除该项参数，并直接调用前一个函数"></a>8.让参数接受者去除该项参数，并直接调用前一个函数</h5><h5 id="9-以一个对象取代此参数"><a href="#9-以一个对象取代此参数" class="headerlink" title="9.以一个对象取代此参数"></a>9.以一个对象取代此参数</h5><h5 id="10-去掉该字段的所有设值函数"><a href="#10-去掉该字段的所有设值函数" class="headerlink" title="10.去掉该字段的所有设值函数"></a>10.去掉该字段的所有设值函数</h5><h5 id="11-将函数修改为private"><a href="#11-将函数修改为private" class="headerlink" title="11.将函数修改为private"></a>11.将函数修改为private</h5><h5 id="12-将构造函数替换为工厂函数"><a href="#12-将构造函数替换为工厂函数" class="headerlink" title="12.将构造函数替换为工厂函数"></a>12.将构造函数替换为工厂函数</h5><h5 id="13-将向下转型动作移到函数中"><a href="#13-将向下转型动作移到函数中" class="headerlink" title="13.将向下转型动作移到函数中"></a>13.将向下转型动作移到函数中</h5><h5 id="14-以异常取代错误码"><a href="#14-以异常取代错误码" class="headerlink" title="14.以异常取代错误码"></a>14.以异常取代错误码</h5><h5 id="15-以测试取代异常"><a href="#15-以测试取代异常" class="headerlink" title="15.以测试取代异常"></a>15.以测试取代异常</h5><h3 id="第十一章，处理概括关系"><a href="#第十一章，处理概括关系" class="headerlink" title="第十一章，处理概括关系"></a>第十一章，处理概括关系</h3><h5 id="1-将子类相同的字段移至父类"><a href="#1-将子类相同的字段移至父类" class="headerlink" title="1.将子类相同的字段移至父类"></a>1.将子类相同的字段移至父类</h5><h5 id="2-将子类相同功能的函数移至父类"><a href="#2-将子类相同功能的函数移至父类" class="headerlink" title="2.将子类相同功能的函数移至父类"></a>2.将子类相同功能的函数移至父类</h5><h5 id="3-如果各子类中拥有一些几乎一致的构造函数，请在父类中新建一个构造函数，并在子类构造函数中调用它"><a href="#3-如果各子类中拥有一些几乎一致的构造函数，请在父类中新建一个构造函数，并在子类构造函数中调用它" class="headerlink" title="3.如果各子类中拥有一些几乎一致的构造函数，请在父类中新建一个构造函数，并在子类构造函数中调用它"></a>3.如果各子类中拥有一些几乎一致的构造函数，请在父类中新建一个构造函数，并在子类构造函数中调用它</h5><h5 id="4-父类中的某个函数只与部分子类相关，将这个函数移到相关的子类去"><a href="#4-父类中的某个函数只与部分子类相关，将这个函数移到相关的子类去" class="headerlink" title="4.父类中的某个函数只与部分子类相关，将这个函数移到相关的子类去"></a>4.父类中的某个函数只与部分子类相关，将这个函数移到相关的子类去</h5><h5 id="5-父类中的某些字段只被部分子类用到，将这个字段移到需要它的子类去"><a href="#5-父类中的某些字段只被部分子类用到，将这个字段移到需要它的子类去" class="headerlink" title="5.父类中的某些字段只被部分子类用到，将这个字段移到需要它的子类去"></a>5.父类中的某些字段只被部分子类用到，将这个字段移到需要它的子类去</h5><h5 id="6-如果类中的某些特性只被某些实例用到，新建一个子类，将那部分的特性移到子类中"><a href="#6-如果类中的某些特性只被某些实例用到，新建一个子类，将那部分的特性移到子类中" class="headerlink" title="6.如果类中的某些特性只被某些实例用到，新建一个子类，将那部分的特性移到子类中"></a>6.如果类中的某些特性只被某些实例用到，新建一个子类，将那部分的特性移到子类中</h5><h5 id="7-如果两个类（或者多个类）有相似特性，为者两个类建立一个超类，将相同特性移至超类"><a href="#7-如果两个类（或者多个类）有相似特性，为者两个类建立一个超类，将相同特性移至超类" class="headerlink" title="7.如果两个类（或者多个类）有相似特性，为者两个类建立一个超类，将相同特性移至超类"></a>7.如果两个类（或者多个类）有相似特性，为者两个类建立一个超类，将相同特性移至超类</h5><h5 id="8-将相同的子集提炼到一个独立接口中"><a href="#8-将相同的子集提炼到一个独立接口中" class="headerlink" title="8.将相同的子集提炼到一个独立接口中"></a>8.将相同的子集提炼到一个独立接口中</h5><h5 id="9-父类和子类之间无太大区别，将它们合为一体"><a href="#9-父类和子类之间无太大区别，将它们合为一体" class="headerlink" title="9.父类和子类之间无太大区别，将它们合为一体"></a>9.父类和子类之间无太大区别，将它们合为一体</h5><h5 id="10-你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同，将这些操作分别放进独立函数中，并保持原函数上移超类"><a href="#10-你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同，将这些操作分别放进独立函数中，并保持原函数上移超类" class="headerlink" title="10.你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同，将这些操作分别放进独立函数中，并保持原函数上移超类"></a>10.你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同，将这些操作分别放进独立函数中，并保持原函数上移超类</h5><h5 id="11-某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据，在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系"><a href="#11-某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据，在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系" class="headerlink" title="11.某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据，在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系"></a>11.某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据，在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系</h5><h5 id="12-在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，让委托类继承受托类"><a href="#12-在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，让委托类继承受托类" class="headerlink" title="12.在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，让委托类继承受托类"></a>12.在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，让委托类继承受托类</h5><h3 id="第十二章，大型重构"><a href="#第十二章，大型重构" class="headerlink" title="第十二章，大型重构"></a>第十二章，大型重构</h3><h5 id="1-如果某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个"><a href="#1-如果某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个" class="headerlink" title="1.如果某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个"></a>1.如果某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个</h5><h5 id="2-将过程化设计转化为对象设计"><a href="#2-将过程化设计转化为对象设计" class="headerlink" title="2.将过程化设计转化为对象设计"></a>2.将过程化设计转化为对象设计</h5><h5 id="3-将领域逻辑分离出来，为它们建立独立的领域类"><a href="#3-将领域逻辑分离出来，为它们建立独立的领域类" class="headerlink" title="3.将领域逻辑分离出来，为它们建立独立的领域类"></a>3.将领域逻辑分离出来，为它们建立独立的领域类</h5><h5 id="4-建立继承体系，以一个子类表示一种特殊情况"><a href="#4-建立继承体系，以一个子类表示一种特殊情况" class="headerlink" title="4.建立继承体系，以一个子类表示一种特殊情况"></a>4.建立继承体系，以一个子类表示一种特殊情况</h5><h3 id="第十三章，重构，复用与实现"><a href="#第十三章，重构，复用与实现" class="headerlink" title="第十三章，重构，复用与实现"></a>第十三章，重构，复用与实现</h3><h5 id="1-重构以求短期利益"><a href="#1-重构以求短期利益" class="headerlink" title="1.重构以求短期利益"></a>1.重构以求短期利益</h5><h5 id="2-降低重构带来的开销"><a href="#2-降低重构带来的开销" class="headerlink" title="2.降低重构带来的开销"></a>2.降低重构带来的开销</h5><h5 id="3-安全地进行重构"><a href="#3-安全地进行重构" class="headerlink" title="3.安全地进行重构"></a>3.安全地进行重构</h5>]]></content>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2024/12/18/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h5><p>1.和出栈比较</p>
<p>2.快慢指针（右边进栈和左边比较）</p>
<p>3.空间O(1)快慢指针把中赋为null右边指针反转，头尾比较等于null退出，把链表复原</p>
<p>栈方法简单（笔试用）</p>
<p>改原链表的方法就需要注意边界了（面试用）</p>
<h5 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h5><p>快慢指针相遇有环（在环上相遇）</p>
<p>快指针为null无环</p>
<p>快指针从头再来慢指针还在原地快慢指针每次走一步，最终会在第一个入环节点处相遇 </p>
<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>样本量</p>
<p>失误率</p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230213173549604.png" alt="image-20230213173549604"></p>
<h5 id="判断一个32位的数是否为2的幂（用位运算）"><a href="#判断一个32位的数是否为2的幂（用位运算）" class="headerlink" title="判断一个32位的数是否为2的幂（用位运算）"></a>判断一个32位的数是否为2的幂（用位运算）</h5><p>x&amp;（x-1）&#x3D;&#x3D;0</p>
<h5 id="判断一个32位的数是否为4的幂（用位运算）"><a href="#判断一个32位的数是否为4的幂（用位运算）" class="headerlink" title="判断一个32位的数是否为4的幂（用位运算）"></a>判断一个32位的数是否为4的幂（用位运算）</h5><p>1.是2的幂</p>
<p>2.x&amp;(0x55555555)!&#x3D;0  &#x2F;&#x2F;0x55555555&#x3D;&#x3D;(010101…01)</p>
<h5 id="计划搜索缓存"><a href="#计划搜索缓存" class="headerlink" title="计划搜索缓存"></a>计划搜索缓存</h5><p>跳过重复条件</p>
<h4 id="二叉树序列化和反序列化"><a href="#二叉树序列化和反序列化" class="headerlink" title="二叉树序列化和反序列化"></a>二叉树序列化和反序列化</h4><h5 id="层次遍历序列化"><a href="#层次遍历序列化" class="headerlink" title="层次遍历序列化"></a><strong>层次遍历序列化</strong></h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806213217639.png" alt="image-20230806213217639"></p>
<h5 id="层次遍历反序列化"><a href="#层次遍历反序列化" class="headerlink" title="层次遍历反序列化"></a><strong>层次遍历反序列化</strong></h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806213548602.png" alt="image-20230806213548602"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806213629196.png" alt="image-20230806213629196"></p>
<h5 id="二叉树的宽度优先遍历（用队列）"><a href="#二叉树的宽度优先遍历（用队列）" class="headerlink" title="二叉树的宽度优先遍历（用队列）"></a>二叉树的宽度优先遍历（用队列）</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806213905494.png" alt="image-20230806213905494"></p>
<h5 id="最大宽度"><a href="#最大宽度" class="headerlink" title="最大宽度"></a><strong>最大宽度</strong></h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806214109771.png" alt="image-20230806214109771"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806214226535.png" alt="image-20230806214226535"></p>
<h5 id="最大宽度不用Map"><a href="#最大宽度不用Map" class="headerlink" title="最大宽度不用Map"></a><strong>最大宽度不用Map</strong></h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806214333014.png" alt="image-20230806214333014"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230806214408305.png" alt="image-20230806214408305"></p>
<h5 id="给二叉树中的某个节点，返回该节点的后继节点"><a href="#给二叉树中的某个节点，返回该节点的后继节点" class="headerlink" title="给二叉树中的某个节点，返回该节点的后继节点"></a>给二叉树中的某个节点，返回该节点的后继节点</h5><p><strong>二叉树的结构</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809162347646.png" alt="image-20230809162347646"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809162357652.png" alt="image-20230809162357652"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809162416499.png" alt="image-20230809162416499"></p>
<h4 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810112617869.png" alt="image-20230810112617869"></p>
<h5 id="请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如-N-x3D-1时，打印-down-N-x3D-2时，打印-down-down-up"><a href="#请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如-N-x3D-1时，打印-down-N-x3D-2时，打印-down-down-up" class="headerlink" title="请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如:N&#x3D;1时，打印: down N&#x3D;2时，打印: down down up"></a>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如:N&#x3D;1时，打印: down N&#x3D;2时，打印: down down up</h5><p><strong>思路：用递归模拟了树（树没有建出来）</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809171948817.png" alt="image-20230809171948817"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809222252698.png" alt="image-20230809222252698"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809222630200.png" alt="image-20230809222630200"></p>
<p><strong>左右高度相差大于1</strong></p>
<h5 id="给定一颗二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离"><a href="#给定一颗二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离" class="headerlink" title="给定一颗二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离"></a>给定一颗二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809224817912.png" alt="image-20230809224817912"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809224938250.png" alt="image-20230809224938250"></p>
<h5 id="给定一颗二叉树的头节点head，返回这颗二叉树中最大的二叉树搜索子树的头节点"><a href="#给定一颗二叉树的头节点head，返回这颗二叉树中最大的二叉树搜索子树的头节点" class="headerlink" title="给定一颗二叉树的头节点head，返回这颗二叉树中最大的二叉树搜索子树的头节点"></a>给定一颗二叉树的头节点head，返回这颗二叉树中最大的二叉树搜索子树的头节点</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809230421725.png" alt="image-20230809230421725"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809230449347.png" alt="image-20230809230449347"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809230758428.png" alt="image-20230809230758428"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809231011832.png" alt="image-20230809231011832"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809232203251.png" alt="image-20230809232203251"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809232212378.png" alt="image-20230809232212378"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230809232248537.png" alt="image-20230809232248537"></p>
<h5 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810112941058.png" alt="image-20230810112941058"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810112905633.png" alt="image-20230810112905633"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810113135757.png" alt="image-20230810113135757"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810113635694.png" alt="image-20230810113635694"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810113735696.png" alt="image-20230810113735696"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810114535187.png" alt="image-20230810114535187"></p>
<h4 id="打表找规律（暴力找规则）"><a href="#打表找规律（暴力找规则）" class="headerlink" title="打表找规律（暴力找规则）"></a>打表找规律（暴力找规则）</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810144117712.png" alt="image-20230810144117712"></p>
<h5 id="牛羊吃草"><a href="#牛羊吃草" class="headerlink" title="牛羊吃草"></a>牛羊吃草</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810172000733.png" alt="image-20230810172000733"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810173035327.png" alt="image-20230810173035327"></p>
<p><strong>规律解法</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810173318524.png" alt="image-20230810173318524"></p>
<h5 id="连续正数和的数"><a href="#连续正数和的数" class="headerlink" title="连续正数和的数"></a>连续正数和的数</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810173457571.png" alt="image-20230810173457571"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810173803716.png" alt="image-20230810173803716"></p>
<p><strong>规律解法</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230810174302249.png" alt="image-20230810174302249"></p>
<h4 id="矩阵处理技巧"><a href="#矩阵处理技巧" class="headerlink" title="矩阵处理技巧"></a>矩阵处理技巧</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811104211653.png" alt="image-20230811104211653"></p>
<h5 id="1-zigzag打印矩阵"><a href="#1-zigzag打印矩阵" class="headerlink" title="1.zigzag打印矩阵"></a>1.zigzag打印矩阵</h5><p><strong>1     2     3</strong></p>
<p><strong>4     5     6 –&gt;  打印输出 124753689</strong></p>
<p><strong>7     8     9</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811110433096.png" alt="image-20230811110433096"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811105705838.png" alt="image-20230811105705838"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811110236636.png" alt="image-20230811110236636"></p>
<h5 id="2-转圈打印矩阵"><a href="#2-转圈打印矩阵" class="headerlink" title="2.转圈打印矩阵"></a>2.转圈打印矩阵</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811110411997.png" alt="image-20230811110411997"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811114403285.png" alt="image-20230811114403285"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811114423365.png" alt="image-20230811114423365"></p>
<h5 id="原地旋转正方形矩阵"><a href="#原地旋转正方形矩阵" class="headerlink" title="原地旋转正方形矩阵"></a>原地旋转正方形矩阵</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230811144228974.png" alt="image-20230811144228974"></p>
<h4 id="贪心算法求解的标准过程"><a href="#贪心算法求解的标准过程" class="headerlink" title="贪心算法求解的标准过程"></a>贪心算法求解的标准过程</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813112401472.png" alt="image-20230813112401472"></p>
<h5 id="解题套路"><a href="#解题套路" class="headerlink" title="解题套路"></a>解题套路</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813112740743.png" alt="image-20230813112740743"></p>
<h5 id="宣讲次数最多"><a href="#宣讲次数最多" class="headerlink" title="宣讲次数最多"></a>宣讲次数最多</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813113328189.png" alt="image-20230813113328189"></p>
<p><strong>结构</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813113837355.png" alt="image-20230813113837355"></p>
<p><strong>暴力解</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813113910857.png" alt="image-20230813113910857"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813114441101.png" alt="image-20230813114441101"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813114509994.png" alt="image-20230813114509994"></p>
<p><strong>第二种</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813114723541.png" alt="image-20230813114723541"></p>
<p>排序（根据谁的时间短排序）</p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230813114749780.png" alt="image-20230813114749780"></p>
<h5 id="最少灯"><a href="#最少灯" class="headerlink" title="最少灯"></a>最少灯</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820205812669.png" alt="image-20230820205812669"></p>
<p><strong>暴力法</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820210413346.png" alt="image-20230820210413346"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820211148939.png" alt="image-20230820211148939"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820211752445.png" alt="image-20230820211752445"></p>
<p><strong>贪心</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820223313263.png" alt="image-20230820223313263"></p>
<h5 id="分金条"><a href="#分金条" class="headerlink" title="分金条"></a>分金条</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820223443749.png" alt="image-20230820223443749"></p>
<p><strong>贪心</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230820232318818.png" alt="image-20230820232318818"></p>
<h5 id="最大盈利"><a href="#最大盈利" class="headerlink" title="最大盈利"></a>最大盈利</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821104437976.png" alt="image-20230821104437976"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821105452745.png" alt="image-20230821105452745"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821105548324.png" alt="image-20230821105548324"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821110249783.png" alt="image-20230821110249783"></p>
<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821114453043.png" alt="image-20230821114453043"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821140231255.png" alt="image-20230821140231255"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821140301524.png" alt="image-20230821140301524"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821140952600.png" alt="image-20230821140952600"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821141131457.png" alt="image-20230821141131457"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821141818964.png" alt="image-20230821141818964"></p>
<p><strong>简写if</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821151929121.png" alt="image-20230821151929121"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821180939615.png" alt="image-20230821180939615"></p>
<h5 id="分类用户（代码与上面的通用）"><a href="#分类用户（代码与上面的通用）" class="headerlink" title="分类用户（代码与上面的通用）"></a>分类用户（代码与上面的通用）</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821174058148.png" alt="image-20230821174058148"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821180116136.png" alt="image-20230821180116136"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821180759052.png" alt="image-20230821180759052"> </p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821181030008.png" alt="image-20230821181030008"></p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821231446493.png" alt="image-20230821231446493"></p>
<h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821212141175.png" alt="image-20230821212141175"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821212315084.png" alt="image-20230821212315084"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821212412295.png" alt="image-20230821212412295"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821231344666.png" alt="image-20230821231344666"></p>
<h5 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230821231614555.png" alt="image-20230821231614555"></p>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822110844232.png" alt="image-20230822110844232"></p>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822111401982.png" alt="image-20230822111401982"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822112326314.png" alt="image-20230822112326314"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822112538795.png" alt="image-20230822112538795"></p>
<h5 id="最小生成树（Kruskal）利用并查集"><a href="#最小生成树（Kruskal）利用并查集" class="headerlink" title="最小生成树（Kruskal）利用并查集"></a>最小生成树（Kruskal）利用并查集</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822112640439.png" alt="image-20230822112640439"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822113624852.png" alt="image-20230822113624852"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822113718582.png" alt="image-20230822113718582"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822113739708.png" alt="image-20230822113739708"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822113803630.png" alt="image-20230822113803630"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822113935676.png" alt="image-20230822113935676"></p>
<h5 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822145412850.png" alt="image-20230822145412850"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822145440847.png" alt="image-20230822145440847"></p>
<h5 id="Dijkstra（迪特拉）"><a href="#Dijkstra（迪特拉）" class="headerlink" title="Dijkstra（迪特拉）"></a>Dijkstra（迪特拉）</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230822232529007.png" alt="image-20230822232529007"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823110800290.png" alt="image-20230823110800290"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823111138330.png" alt="image-20230823111138330"></p>
<p><strong>改进</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823112308639.png" alt="image-20230823112308639"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823112554966.png" alt="image-20230823112554966"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823112925026.png" alt="image-20230823112925026"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823113520659.png" alt="image-20230823113520659"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823114014177.png" alt="image-20230823114014177"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823114040638.png" alt="image-20230823114040638"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823114112602.png" alt="image-20230823114112602"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823114139494.png" alt="image-20230823114139494"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823112458303.png" alt="image-20230823112458303"></p>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra1</span><span class="params">(Node from)</span> &#123;</span><br><span class="line">		HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		distanceMap.put(from, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 打过对号的点</span></span><br><span class="line">		HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">		<span class="keyword">while</span> (minNode != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//  原始点  -&gt;  minNode(跳转点)   最小距离distance</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> distanceMap.get(minNode);</span><br><span class="line">			<span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;</span><br><span class="line">				<span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">					distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// toNode </span></span><br><span class="line">					distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			selectedNodes.add(minNode);</span><br><span class="line">			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> distanceMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">			<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">			<span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">				minNode = node;</span><br><span class="line">				minDistance = distance;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeRecord</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> Node node;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> distance;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">NodeRecord</span><span class="params">(Node node, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.node = node;</span><br><span class="line">			<span class="built_in">this</span>.distance = distance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeHeap</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> Node[] nodes; <span class="comment">// 实际的堆结构</span></span><br><span class="line">		<span class="comment">// key 某一个node， value 上面堆中的位置</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;</span><br><span class="line">		<span class="comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 堆上有多少个点</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">NodeHeap</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">			nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">			heapIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span></span><br><span class="line">		<span class="comment">// 判断要不要更新，如果需要的话，就更新</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (inHeap(node)) &#123;</span><br><span class="line">				distanceMap.put(node, Math.min(distanceMap.get(node), distance));</span><br><span class="line">				insertHeapify(heapIndexMap.get(node));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isEntered(node)) &#123;</span><br><span class="line">				nodes[size] = node;</span><br><span class="line">				heapIndexMap.put(node, size);</span><br><span class="line">				distanceMap.put(node, distance);</span><br><span class="line">				insertHeapify(size++);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> NodeRecord <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">NodeRecord</span> <span class="variable">nodeRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeRecord</span>(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));</span><br><span class="line">			swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">			heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>);</span><br><span class="line">			distanceMap.remove(nodes[size - <span class="number">1</span>]);</span><br><span class="line">			<span class="comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span></span><br><span class="line">			nodes[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">			heapify(<span class="number">0</span>, --size);</span><br><span class="line">			<span class="keyword">return</span> nodeRecord;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertHeapify</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">				swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">				index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">						? left + <span class="number">1</span></span><br><span class="line">						: left;</span><br><span class="line">				smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">				<span class="keyword">if</span> (smallest == index) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				swap(smallest, index);</span><br><span class="line">				index = smallest;</span><br><span class="line">				left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEntered</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inHeap</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">			heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">			heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">			<span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> nodes[index1];</span><br><span class="line">			nodes[index1] = nodes[index2];</span><br><span class="line">			nodes[index2] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改进后的dijkstra算法</span></span><br><span class="line">	<span class="comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra2</span><span class="params">(Node head, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">		<span class="type">NodeHeap</span> <span class="variable">nodeHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeHeap</span>(size);</span><br><span class="line">		nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);</span><br><span class="line">		HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">			<span class="type">NodeRecord</span> <span class="variable">record</span> <span class="operator">=</span> nodeHeap.pop();</span><br><span class="line">			<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> record.node;</span><br><span class="line">			<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> record.distance;</span><br><span class="line">			<span class="keyword">for</span> (Edge edge : cur.edges) &#123;</span><br><span class="line">				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">			&#125;</span><br><span class="line">			result.put(cur, distance);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823204258520.png" alt="image-20230823204258520"></p>
<h5 id="什么暴力递归可以继续优化"><a href="#什么暴力递归可以继续优化" class="headerlink" title="什么暴力递归可以继续优化"></a>什么暴力递归可以继续优化</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230828222645533.png" alt="image-20230828222645533"></p>
<h5 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h5><p><strong>递归</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823211340601.png" alt="image-20230823211340601"></p>
<p><strong>非递归</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823222133911.png" alt="image-20230823222133911"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823222724786.png" alt="image-20230823222724786"></p>
<h5 id="逆序栈"><a href="#逆序栈" class="headerlink" title="逆序栈"></a>逆序栈</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823231626306.png" alt="image-20230823231626306"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230823231612471.png" alt="image-20230823231612471"></p>
<h5 id="字符串的子序列"><a href="#字符串的子序列" class="headerlink" title="字符串的子序列"></a>字符串的子序列</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824113149359.png" alt="image-20230824113149359"></p>
<h5 id="无重复子序列"><a href="#无重复子序列" class="headerlink" title="无重复子序列"></a>无重复子序列</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824113707209.png" alt="image-20230824113707209"></p>
<h5 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824115400920.png" alt="image-20230824115400920"></p>
<h5 id="无重复全排列（分支限界）"><a href="#无重复全排列（分支限界）" class="headerlink" title="无重复全排列（分支限界）"></a>无重复全排列（分支限界）</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824145424003.png" alt="image-20230824145424003"></p>
<h5 id="数字字符转化"><a href="#数字字符转化" class="headerlink" title="数字字符转化"></a>数字字符转化</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824155941335.png" alt="image-20230824155941335"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824164902728.png" alt="image-20230824164902728"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824165337040.png" alt="image-20230824165337040"></p>
<h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824165604366.png" alt="image-20230824165604366"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824171910002.png" alt="image-20230824171910002"></p>
<p><strong>另一种</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824172343341.png" alt="image-20230824172343341"></p>
<h5 id="选牌"><a href="#选牌" class="headerlink" title="选牌"></a>选牌</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824210400917.png" alt="image-20230824210400917"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824211521667.png" alt="image-20230824211521667"></p>
<h5 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230825114042751.png" alt="image-20230825114042751"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230825114051687.png" alt="image-20230825114051687"></p>
<p><strong>利用位移</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230825230205985.png" alt="image-20230825230205985"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230825232031733.png" alt="image-20230825232031733"></p>
<h5 id="货币凑整"><a href="#货币凑整" class="headerlink" title="货币凑整"></a>货币凑整</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了</span></span><br><span class="line">		<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">		ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="递归改动态规划（题目同上面相同）"><a href="#递归改动态规划（题目同上面相同）" class="headerlink" title="递归改动态规划（题目同上面相同）"></a>递归改动态规划（题目同上面相同）</h4><h5 id="步骤：暴力递归（重复解）-gt-可变参数（不讲究组织）-gt-记忆化搜索（精细化组织）-gt-经典动态规划"><a href="#步骤：暴力递归（重复解）-gt-可变参数（不讲究组织）-gt-记忆化搜索（精细化组织）-gt-经典动态规划" class="headerlink" title="步骤：暴力递归（重复解）-&gt;可变参数（不讲究组织）-&gt;记忆化搜索（精细化组织）-&gt;经典动态规划"></a>步骤：暴力递归（重复解）-&gt;可变参数（不讲究组织）-&gt;记忆化搜索（精细化组织）-&gt;经典动态规划</h5><h5 id="回到原始位置"><a href="#回到原始位置" class="headerlink" title="回到原始位置"></a>回到原始位置</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230826104530266.png" alt="image-20230826104530266"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230826105655576.png" alt="image-20230826105655576"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230826105712842.png" alt="image-20230826105712842"></p>
<p><strong>2</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230827114242417.png" alt="image-20230827114242417"></p>
<h5 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230826110737375.png" alt="image-20230826110737375"></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230826111741326.png" alt="image-20230826111741326"></p>
<p><strong>2</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230827114418035.png" alt="image-20230827114418035"></p>
<h5 id="数字字符转化-1"><a href="#数字字符转化-1" class="headerlink" title="数字字符转化"></a>数字字符转化</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230824155941335.png" alt="image-20230824155941335"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从右往左的动态规划</span></span><br><span class="line"><span class="comment">// 就是上面方法的动态规划版本</span></span><br><span class="line"><span class="comment">// dp[i]表示：str[i...]有多少种转化方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">	<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">	dp[N] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> dp[i + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">				ways += dp[i + <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左往右的动态规划</span></span><br><span class="line"><span class="comment">// dp[i]表示：str[0...i]有多少种转化方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果此时str[i]==&#x27;0&#x27;，那么他是一定要拉前一个字符(i-1的字符)一起拼的，</span></span><br><span class="line">			<span class="comment">// 那么就要求前一个字符，不能也是‘0’，否则拼不了。</span></span><br><span class="line">			<span class="comment">// 前一个字符不是‘0’就够了嘛？不够，还得要求拼完了要么是10，要么是20，如果更大的话，拼不了。</span></span><br><span class="line">			<span class="comment">// 这就够了嘛？还不够，你们拼完了，还得要求str[0...i-2]真的可以被分解！</span></span><br><span class="line">			<span class="comment">// 如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行，因为之前的搞定不了。</span></span><br><span class="line">			<span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> || str[i - <span class="number">1</span>] &gt; <span class="string">&#x27;2&#x27;</span> || (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">2</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i] = i - <span class="number">2</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">2</span>] : <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (str[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (str[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">				dp[i] += i - <span class="number">2</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">2</span>] : <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选牌-1"><a href="#选牌-1" class="headerlink" title="选牌"></a>选牌</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">		<span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			fmap[i][i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line">			<span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">				fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]);</span><br><span class="line">				gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]);</span><br><span class="line">				L++;</span><br><span class="line">				R++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="货币凑整-1"><a href="#货币凑整-1" class="headerlink" title="货币凑整"></a>货币凑整</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">				ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[index][rest] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">			dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">			<span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="贴纸字符串"><a href="#贴纸字符串" class="headerlink" title="贴纸字符串"></a>贴纸字符串</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers2</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">	<span class="comment">// 关键优化(用词频表替代贴纸数组)</span></span><br><span class="line">	<span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">			counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process2(counts, target);</span><br><span class="line">	<span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -&gt; 所有的贴纸</span></span><br><span class="line"><span class="comment">// 每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// 返回搞定target的最少张数</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[][] stickers, String t)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// target做出词频统计</span></span><br><span class="line">	<span class="comment">// target  aabbc  2 2 1..</span></span><br><span class="line">	<span class="comment">//                0 1 2..</span></span><br><span class="line">	<span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line">	<span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">		tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="comment">// 尝试第一张贴纸是谁</span></span><br><span class="line">		<span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line">		<span class="comment">// 最关键的优化(重要的剪枝!这一步也是贪心!)</span></span><br><span class="line">		<span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">						builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">			min = Math.min(min, process2(stickers, rest));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers3</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">	<span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">			counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	dp.put(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process3(counts, target, dp);</span><br><span class="line">	<span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process3</span><span class="params">(<span class="type">int</span>[][] stickers, String t, HashMap&lt;String, Integer&gt; dp)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (dp.containsKey(t)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dp.get(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line">	<span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">		tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line">		<span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">						builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">			min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	dp.put(t, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两个字符串的最长公共子序列"><a href="#两个字符串的最长公共子序列" class="headerlink" title="两个字符串的最长公共子序列"></a>两个字符串的最长公共子序列</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">			dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">				dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="洗咖啡杯机"><a href="#洗咖啡杯机" class="headerlink" title="洗咖啡杯机"></a>洗咖啡杯机</h5><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230829141719016.png" alt="image-20230829141719016"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贪心+优良尝试改成动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minTime2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	PriorityQueue&lt;Machine&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Machine&gt;(<span class="keyword">new</span> <span class="title class_">MachineComparator</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		heap.add(<span class="keyword">new</span> <span class="title class_">Machine</span>(<span class="number">0</span>, arr[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>[] drinks = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">Machine</span> <span class="variable">cur</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">		cur.timePoint += cur.workTime;</span><br><span class="line">		drinks[i] = cur.timePoint;</span><br><span class="line">		heap.add(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bestTimeDp(drinks, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bestTimeDp</span><span class="params">(<span class="type">int</span>[] drinks, <span class="type">int</span> wash, <span class="type">int</span> air)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> drinks.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">maxFree</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; drinks.length; i++) &#123;</span><br><span class="line">		maxFree = Math.max(maxFree, drinks[i]) + wash;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][maxFree + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">free</span> <span class="operator">=</span> <span class="number">0</span>; free &lt;= maxFree; free++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">selfClean1</span> <span class="operator">=</span> Math.max(drinks[index], free) + wash;</span><br><span class="line">			<span class="keyword">if</span> (selfClean1 &gt; maxFree) &#123;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 因为后面的也都不用填了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// index号杯子 决定洗</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">restClean1</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][selfClean1];</span><br><span class="line">			<span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> Math.max(selfClean1, restClean1);</span><br><span class="line">			<span class="comment">// index号杯子 决定挥发</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">selfClean2</span> <span class="operator">=</span> drinks[index] + air;</span><br><span class="line">			<span class="type">int</span> <span class="variable">restClean2</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][free];</span><br><span class="line">			<span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> Math.max(selfClean2, restClean2);</span><br><span class="line">			dp[index][free] = Math.min(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="设计暴力递归过程的原则"><a href="#设计暴力递归过程的原则" class="headerlink" title="设计暴力递归过程的原则"></a>设计暴力递归过程的原则</h4><p><img src="/%E7%AE%97%E6%B3%95%5Cimage-20230829104524129.png" alt="image-20230829104524129"></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA建议</title>
    <url>/2024/09/17/JAVA%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<h4 id="1-考虑用静态工厂方法代替构造函数"><a href="#1-考虑用静态工厂方法代替构造函数" class="headerlink" title="1.考虑用静态工厂方法代替构造函数"></a>1.考虑用静态工厂方法代替构造函数</h4><p><strong>静态工厂方法的好处</strong></p>
<p><strong>1.与构造函数不同,静态工厂方法具有名字</strong></p>
<p><strong>2.与构造函数不同，它们每次被调用的时候，不要求非得创建一个新的对象</strong></p>
<p><strong>3.与构造函数不同，它可以返回一个原返回类型的子类型的对象</strong></p>
<p><strong>缺点</strong></p>
<h5 id="主要：类如果不含公有的或者受保护的构造函数，就不能被子类化"><a href="#主要：类如果不含公有的或者受保护的构造函数，就不能被子类化" class="headerlink" title="主要：类如果不含公有的或者受保护的构造函数，就不能被子类化"></a>主要：类如果不含公有的或者受保护的构造函数，就不能被子类化</h5><p><strong>2.它们与其他的静态方法没有任何区别</strong></p>
<h4 id="2-使用私有构造函数强化singleton属性"><a href="#2-使用私有构造函数强化singleton属性" class="headerlink" title="2.使用私有构造函数强化singleton属性"></a>2.使用私有构造函数强化singleton属性</h4><h4 id="3-通过私有构造函数强化不可实例化的能力"><a href="#3-通过私有构造函数强化不可实例化的能力" class="headerlink" title="3.通过私有构造函数强化不可实例化的能力"></a>3.通过私有构造函数强化不可实例化的能力</h4><h4 id="4-避免创建重复的对象"><a href="#4-避免创建重复的对象" class="headerlink" title="4.避免创建重复的对象"></a>4.避免创建重复的对象</h4><h4 id="5-消除过期的对象引用"><a href="#5-消除过期的对象引用" class="headerlink" title="5.消除过期的对象引用"></a>5.消除过期的对象引用</h4><h4 id="6-避免使用终结函数"><a href="#6-避免使用终结函数" class="headerlink" title="6.避免使用终结函数"></a>6.避免使用终结函数</h4><h4 id="7-在改写equals的时候请遵守通用约定"><a href="#7-在改写equals的时候请遵守通用约定" class="headerlink" title="7.在改写equals的时候请遵守通用约定"></a>7.在改写equals的时候请遵守通用约定</h4><h4 id="8-在改写equals时总是要改写hashCods"><a href="#8-在改写equals时总是要改写hashCods" class="headerlink" title="8.在改写equals时总是要改写hashCods"></a>8.在改写equals时总是要改写hashCods</h4><h4 id="9-总是要改写toString"><a href="#9-总是要改写toString" class="headerlink" title="9.总是要改写toString"></a>9.总是要改写toString</h4><h4 id="10-谨慎改写clone"><a href="#10-谨慎改写clone" class="headerlink" title="10.谨慎改写clone"></a>10.谨慎改写clone</h4><h4 id="11-考虑实现Comparable接口"><a href="#11-考虑实现Comparable接口" class="headerlink" title="11.考虑实现Comparable接口"></a>11.考虑实现Comparable接口</h4><h4 id="12-使类和成员的可访问能力最小化"><a href="#12-使类和成员的可访问能力最小化" class="headerlink" title="12.使类和成员的可访问能力最小化"></a>12.使类和成员的可访问能力最小化</h4><p><strong>尽可能使每一个类或成员不被外界访问</strong></p>
<h4 id="13-支持非可变性"><a href="#13-支持非可变性" class="headerlink" title="13.支持非可变性"></a>13.支持非可变性</h4><h5 id="1-不要提供任何会修改对象的方法（也称为mutator）"><a href="#1-不要提供任何会修改对象的方法（也称为mutator）" class="headerlink" title="1.不要提供任何会修改对象的方法（也称为mutator）"></a>1.不要提供任何会修改对象的方法（也称为mutator）</h5><h5 id="2-保证没有可被子类改写的方法"><a href="#2-保证没有可被子类改写的方法" class="headerlink" title="2.保证没有可被子类改写的方法"></a>2.保证没有可被子类改写的方法</h5><h5 id="3-使所有的域都是final的"><a href="#3-使所有的域都是final的" class="headerlink" title="3.使所有的域都是final的"></a>3.使所有的域都是final的</h5><h5 id="4-使所有域都是成为私有的"><a href="#4-使所有域都是成为私有的" class="headerlink" title="4.使所有域都是成为私有的"></a>4.使所有域都是成为私有的</h5><h5 id="5-保证对于任何可变组件的互斥访问"><a href="#5-保证对于任何可变组件的互斥访问" class="headerlink" title="5.保证对于任何可变组件的互斥访问"></a>5.保证对于任何可变组件的互斥访问</h5><h4 id="14-复合优先于继承"><a href="#14-复合优先于继承" class="headerlink" title="14.复合优先于继承"></a>14.复合优先于继承</h4><h4 id="15-要么专门为继承而设计，并给出文档说明，要么禁止继承"><a href="#15-要么专门为继承而设计，并给出文档说明，要么禁止继承" class="headerlink" title="15.要么专门为继承而设计，并给出文档说明，要么禁止继承"></a>15.要么专门为继承而设计，并给出文档说明，要么禁止继承</h4><p><strong>一个类必须通过某种形式提供适合的钩子，以便能够进入到它的内部工作流程中，这样的形式可以是精心选择的受保护（protected）方法</strong></p>
<p><strong>构造函数一定不能调用可被改写的方法</strong></p>
<p><strong>无论是clone还是readObject，都不能调用一个可改写的方法，不管是直接的方式，还是间接的方式</strong></p>
<p><strong>为了继承设计一个类，要求对这个类有一些实质性的限制</strong></p>
<p><strong>对于那些并非为了安全地进行子类化而设计和编写文档类，禁止子类化</strong></p>
<h5 id="禁止子类化的两种方法"><a href="#禁止子类化的两种方法" class="headerlink" title="禁止子类化的两种方法"></a>禁止子类化的两种方法</h5><p><strong>1.直接把这个类声明为final的</strong></p>
<p><strong>2.把所有的构造函数变成私有的，或者包级私有的，并且增加一些公有的静态工厂来替代构造函数的位置</strong></p>
<h4 id="16接口优于抽象类"><a href="#16接口优于抽象类" class="headerlink" title="16接口优于抽象类"></a>16接口优于抽象类</h4><p><strong>接口和抽象类最大的区别是：抽象类允许包含某些方法的实现，但是接口是不允许的</strong></p>
<h5 id="已有的类可以很容易被更新，已实现新的接口"><a href="#已有的类可以很容易被更新，已实现新的接口" class="headerlink" title="已有的类可以很容易被更新，已实现新的接口"></a>已有的类可以很容易被更新，已实现新的接口</h5><h5 id="接口是定义mixin（混合类型）的理想选择"><a href="#接口是定义mixin（混合类型）的理想选择" class="headerlink" title="接口是定义mixin（混合类型）的理想选择"></a>接口是定义mixin（混合类型）的理想选择</h5><h5 id="接口使得我们可以构造出非层次结构的类型框架"><a href="#接口使得我们可以构造出非层次结构的类型框架" class="headerlink" title="接口使得我们可以构造出非层次结构的类型框架"></a>接口使得我们可以构造出非层次结构的类型框架</h5><h5 id="接口使得安全地增强一个类的功能成为可能"><a href="#接口使得安全地增强一个类的功能成为可能" class="headerlink" title="接口使得安全地增强一个类的功能成为可能"></a>接口使得安全地增强一个类的功能成为可能</h5><p><strong>你可以把接口和抽象类的优点结合起来，对于你期望导出的每一个重要接口，都提供一个抽象的骨架实现（skeletal implementation）类</strong></p>
<h5 id="抽象类的演化比接口的演化要容易得多"><a href="#抽象类的演化比接口的演化要容易得多" class="headerlink" title="抽象类的演化比接口的演化要容易得多"></a>抽象类的演化比接口的演化要容易得多</h5><h4 id="17-接口只是被用于定义类型"><a href="#17-接口只是被用于定义类型" class="headerlink" title="17.接口只是被用于定义类型"></a>17.接口只是被用于定义类型</h4><p><strong>常量接口模式是对接口的不良使用</strong></p>
<h4 id="18-优先考虑静态成员类"><a href="#18-优先考虑静态成员类" class="headerlink" title="18.优先考虑静态成员类"></a>18.优先考虑静态成员类</h4><p><strong>如果你声明的成员类不要求访问外围实例，那么请记住把static修饰符放到成员类的声明中</strong></p>
<h4 id="19-用类代替结构"><a href="#19-用类代替结构" class="headerlink" title="19.用类代替结构"></a>19.用类代替结构</h4><h4 id="20-用类层次来代替联合"><a href="#20-用类层次来代替联合" class="headerlink" title="20.用类层次来代替联合"></a>20.用类层次来代替联合</h4><h4 id="21-用类来代替enum结构"><a href="#21-用类来代替enum结构" class="headerlink" title="21.用类来代替enum结构"></a>21.用类来代替enum结构</h4><h4 id="22-用类和接口来代替函数指针"><a href="#22-用类和接口来代替函数指针" class="headerlink" title="22.用类和接口来代替函数指针"></a>22.用类和接口来代替函数指针</h4><h4 id="23-检查参数的有效性"><a href="#23-检查参数的有效性" class="headerlink" title="23.检查参数的有效性"></a>23.检查参数的有效性</h4><h4 id="24-需要时使用保护性拷贝"><a href="#24-需要时使用保护性拷贝" class="headerlink" title="24.需要时使用保护性拷贝"></a>24.需要时使用保护性拷贝</h4><h5 id="假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序"><a href="#假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序" class="headerlink" title="假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序"></a>假设类的客户会尽一切手段来破坏这个类的约束条件，在这样的前提下，你必须保护性地设计程序</h5><h5 id="对于构造函数的每个可变参数进行保护性拷贝（defensive-copy）是必要的"><a href="#对于构造函数的每个可变参数进行保护性拷贝（defensive-copy）是必要的" class="headerlink" title="对于构造函数的每个可变参数进行保护性拷贝（defensive copy）是必要的"></a>对于构造函数的每个可变参数进行保护性拷贝（defensive copy）是必要的</h5><h5 id="保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象"><a href="#保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象" class="headerlink" title="保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象"></a>保护性拷贝动作是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象</h5><h5 id="对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝"><a href="#对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝" class="headerlink" title="对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝"></a>对于“参数类型可以被不可信方子类化”的情形，请不要使用clone方法进行参数的保护性拷贝</h5><h4 id="25-谨慎设计方法的原型"><a href="#25-谨慎设计方法的原型" class="headerlink" title="25.谨慎设计方法的原型"></a>25.谨慎设计方法的原型</h4><h5 id="谨慎选择方法的名字"><a href="#谨慎选择方法的名字" class="headerlink" title="谨慎选择方法的名字"></a>谨慎选择方法的名字</h5><h5 id="不要过于追求提供便利的方法"><a href="#不要过于追求提供便利的方法" class="headerlink" title="不要过于追求提供便利的方法"></a>不要过于追求提供便利的方法</h5><h5 id="避免长长的参数列表"><a href="#避免长长的参数列表" class="headerlink" title="避免长长的参数列表"></a>避免长长的参数列表</h5><h5 id="对于参数类型，优先使用接口而不是类"><a href="#对于参数类型，优先使用接口而不是类" class="headerlink" title="对于参数类型，优先使用接口而不是类"></a>对于参数类型，优先使用接口而不是类</h5><h5 id="谨慎地使用函数对象"><a href="#谨慎地使用函数对象" class="headerlink" title="谨慎地使用函数对象"></a>谨慎地使用函数对象</h5><h4 id="26-谨慎地使用重载"><a href="#26-谨慎地使用重载" class="headerlink" title="26.谨慎地使用重载"></a>26.谨慎地使用重载</h4><h5 id="对于重载该方法（overloaded-method）的选择是静态的，而对于被改写的方法（overridden-method）的选择是动态的"><a href="#对于重载该方法（overloaded-method）的选择是静态的，而对于被改写的方法（overridden-method）的选择是动态的" class="headerlink" title="对于重载该方法（overloaded method）的选择是静态的，而对于被改写的方法（overridden method）的选择是动态的"></a>对于重载该方法（overloaded method）的选择是静态的，而对于被改写的方法（overridden method）的选择是动态的</h5><h5 id="避免方法重载机制的混淆用法"><a href="#避免方法重载机制的混淆用法" class="headerlink" title="避免方法重载机制的混淆用法"></a>避免方法重载机制的混淆用法</h5><h5 id="一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法"><a href="#一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法" class="headerlink" title="一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法"></a>一个安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法</h5><h4 id="27-返回零长度的数组而不是null"><a href="#27-返回零长度的数组而不是null" class="headerlink" title="27.返回零长度的数组而不是null"></a>27.返回零长度的数组而不是null</h4><h5 id="没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组"><a href="#没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组" class="headerlink" title="没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组"></a>没有理由从一个取数组值（array-valued）的方法中返回null，而不是返回一个零长度数组</h5><h4 id="28-为所有导出的API元素编写文档注释"><a href="#28-为所有导出的API元素编写文档注释" class="headerlink" title="28.为所有导出的API元素编写文档注释"></a>28.为所有导出的API元素编写文档注释</h4><h5 id="为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释"><a href="#为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释" class="headerlink" title="为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释"></a>为了正确地编写API文档，你必须在每一个被导出的类，接口，构造函数，方法和域声明之前增加一个文档注释</h5><h5 id="每一个方法的文档注释应该简洁地描述出它和客户之间的约定"><a href="#每一个方法的文档注释应该简洁地描述出它和客户之间的约定" class="headerlink" title="每一个方法的文档注释应该简洁地描述出它和客户之间的约定"></a>每一个方法的文档注释应该简洁地描述出它和客户之间的约定</h5><h4 id="29-将局部变量的作用域最小化"><a href="#29-将局部变量的作用域最小化" class="headerlink" title="29.将局部变量的作用域最小化"></a>29.将局部变量的作用域最小化</h4><h5 id="使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明"><a href="#使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明" class="headerlink" title="使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明"></a>使一个局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明</h5><h5 id="几乎每一个局部变量的声明都应该包含一个初始化表达式"><a href="#几乎每一个局部变量的声明都应该包含一个初始化表达式" class="headerlink" title="几乎每一个局部变量的声明都应该包含一个初始化表达式"></a>几乎每一个局部变量的声明都应该包含一个初始化表达式</h5><h4 id="30-了解和使用库"><a href="#30-了解和使用库" class="headerlink" title="30.了解和使用库"></a>30.了解和使用库</h4><h5 id="通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验"><a href="#通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验" class="headerlink" title="通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验"></a>通过使用标准库，你可以充分利用这些编写标准库的专家的知识，以及在你之前其他人的使用经验</h5><h5 id="在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的"><a href="#在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的" class="headerlink" title="在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的"></a>在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保持同步是值得的</h5><h4 id="31-如果要求精确的答案，请避免使用float和double"><a href="#31-如果要求精确的答案，请避免使用float和double" class="headerlink" title="31.如果要求精确的答案，请避免使用float和double"></a>31.如果要求精确的答案，请避免使用float和double</h4><h4 id="32-如果其他类型更合适，则尽量避免使用字符串"><a href="#32-如果其他类型更合适，则尽量避免使用字符串" class="headerlink" title="32.如果其他类型更合适，则尽量避免使用字符串"></a>32.如果其他类型更合适，则尽量避免使用字符串</h4><h5 id="字符串不适合代替其他的值类型"><a href="#字符串不适合代替其他的值类型" class="headerlink" title="字符串不适合代替其他的值类型"></a>字符串不适合代替其他的值类型</h5><h5 id="字符串不适合代替枚举类型"><a href="#字符串不适合代替枚举类型" class="headerlink" title="字符串不适合代替枚举类型"></a>字符串不适合代替枚举类型</h5><h5 id="字符串不适合代替聚集类型"><a href="#字符串不适合代替聚集类型" class="headerlink" title="字符串不适合代替聚集类型"></a>字符串不适合代替聚集类型</h5><h5 id="字符串也不适合代替能力表"><a href="#字符串也不适合代替能力表" class="headerlink" title="字符串也不适合代替能力表"></a>字符串也不适合代替能力表</h5><h4 id="33-了解字符串连接的性能"><a href="#33-了解字符串连接的性能" class="headerlink" title="33.了解字符串连接的性能"></a>33.了解字符串连接的性能</h4><h5 id="为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间"><a href="#为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间" class="headerlink" title="为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间"></a>为连接n个字符串而重复地使用字符串连接操作符，要求n的平方级的时间</h5><h5 id="为了获得可接受的性能，请使用StringBuffer替代String"><a href="#为了获得可接受的性能，请使用StringBuffer替代String" class="headerlink" title="为了获得可接受的性能，请使用StringBuffer替代String"></a>为了获得可接受的性能，请使用StringBuffer替代String</h5><h4 id="34-通过接口引用对象"><a href="#34-通过接口引用对象" class="headerlink" title="34.通过接口引用对象"></a>34.通过接口引用对象</h4><h5 id="如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活"><a href="#如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活" class="headerlink" title="如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活"></a>如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活</h5><h5 id="如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的"><a href="#如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的" class="headerlink" title="如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的"></a>如果没有合适的接口存在的话，那么，用类而不是接口来引用一个对象，是完全合适的</h5><h4 id="35-接口优先于映像机制"><a href="#35-接口优先于映像机制" class="headerlink" title="35.接口优先于映像机制"></a>35.接口优先于映像机制</h4><h5 id="映像机制的代价"><a href="#映像机制的代价" class="headerlink" title="映像机制的代价"></a>映像机制的代价</h5><h5 id="损失了编译时类型检查的好处"><a href="#损失了编译时类型检查的好处" class="headerlink" title="损失了编译时类型检查的好处"></a>损失了编译时类型检查的好处</h5><h5 id="要求执行映像访问的代码非常笨拙和冗长"><a href="#要求执行映像访问的代码非常笨拙和冗长" class="headerlink" title="要求执行映像访问的代码非常笨拙和冗长"></a>要求执行映像访问的代码非常笨拙和冗长</h5><h5 id="性能损失"><a href="#性能损失" class="headerlink" title="性能损失"></a>性能损失</h5><h5 id="通常，普通应用在运行时刻不应该以映像方式访问对象"><a href="#通常，普通应用在运行时刻不应该以映像方式访问对象" class="headerlink" title="通常，普通应用在运行时刻不应该以映像方式访问对象"></a>通常，普通应用在运行时刻不应该以映像方式访问对象</h5><h5 id="如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处"><a href="#如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处" class="headerlink" title="如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处"></a>如果只是在很有限的情况下使用映像机制，那么虽然也会付出少许代价，但你可以获得许多好处</h5><h4 id="36-谨慎地使用本地方法"><a href="#36-谨慎地使用本地方法" class="headerlink" title="36.谨慎地使用本地方法"></a>36.谨慎地使用本地方法</h4><h4 id="37-谨慎地进行优化"><a href="#37-谨慎地进行优化" class="headerlink" title="37.谨慎地进行优化"></a>37.谨慎地进行优化</h4><h5 id="努力避免那些限制性能的设计决定"><a href="#努力避免那些限制性能的设计决定" class="headerlink" title="努力避免那些限制性能的设计决定"></a>努力避免那些限制性能的设计决定</h5><h5 id="考虑你的API设计决定的性能后果"><a href="#考虑你的API设计决定的性能后果" class="headerlink" title="考虑你的API设计决定的性能后果"></a>考虑你的API设计决定的性能后果</h5><h5 id="为了获得好的性能而对API进行曲改，这是一个非常不好的想法"><a href="#为了获得好的性能而对API进行曲改，这是一个非常不好的想法" class="headerlink" title="为了获得好的性能而对API进行曲改，这是一个非常不好的想法"></a>为了获得好的性能而对API进行曲改，这是一个非常不好的想法</h5><h5 id="在每次试图做优化之前和之后，请对性能进行测量"><a href="#在每次试图做优化之前和之后，请对性能进行测量" class="headerlink" title="在每次试图做优化之前和之后，请对性能进行测量"></a>在每次试图做优化之前和之后，请对性能进行测量</h5><h4 id="39-只针对不正常的条件才使用异常"><a href="#39-只针对不正常的条件才使用异常" class="headerlink" title="39.只针对不正常的条件才使用异常"></a>39.只针对不正常的条件才使用异常</h4><h4 id="38-遵守普遍接受的命名惯例"><a href="#38-遵守普遍接受的命名惯例" class="headerlink" title="38.遵守普遍接受的命名惯例"></a>38.遵守普遍接受的命名惯例</h4><h5 id="异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流"><a href="#异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流" class="headerlink" title="异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流"></a>异常只应该被同于不正常的条件，它们永远不应该被用于正常的控制流</h5><h5 id="一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常"><a href="#一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常" class="headerlink" title="一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常"></a>一个设计良好的API不应该强迫它的客户为了正常的控制流而使用异常</h5><h4 id="40-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"><a href="#40-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常" class="headerlink" title="40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"></a>40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常</h4><h5 id="如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常"><a href="#如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常" class="headerlink" title="如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常"></a>如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常</h5><h5 id="用运行时异常来指明程序错误"><a href="#用运行时异常来指明程序错误" class="headerlink" title="用运行时异常来指明程序错误"></a>用运行时异常来指明程序错误</h5><h5 id="你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）"><a href="#你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）" class="headerlink" title="你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）"></a>你所实现的所有的未被检查的抛出结构都应该时RuntimeException的子类（直接的或者间接的）</h5><h4 id="41-避免不必要地使用被检查的异常"><a href="#41-避免不必要地使用被检查的异常" class="headerlink" title="41.避免不必要地使用被检查的异常"></a>41.避免不必要地使用被检查的异常</h4><h4 id="42-尽量使用标准的异常"><a href="#42-尽量使用标准的异常" class="headerlink" title="42.尽量使用标准的异常"></a>42.尽量使用标准的异常</h4><h4 id="43-抛出的异常要适合于相应的抽象"><a href="#43-抛出的异常要适合于相应的抽象" class="headerlink" title="43.抛出的异常要适合于相应的抽象"></a>43.抛出的异常要适合于相应的抽象</h4><h5 id="高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常"><a href="#高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常" class="headerlink" title="高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常"></a>高层的实现应该捕获底层的异常，同时抛出一个可以按照高层抽象进行解释的异常</h5><h5 id="尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用"><a href="#尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用" class="headerlink" title="尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用"></a>尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用</h5><h4 id="44-每个方法抛出的异常都要有文档"><a href="#44-每个方法抛出的异常都要有文档" class="headerlink" title="44.每个方法抛出的异常都要有文档"></a>44.每个方法抛出的异常都要有文档</h4><h5 id="总是要单独地声明被检查的异常，并且利用Javadoc的-throws标记，标准地记录下每个异常被抛出的条件"><a href="#总是要单独地声明被检查的异常，并且利用Javadoc的-throws标记，标准地记录下每个异常被抛出的条件" class="headerlink" title="总是要单独地声明被检查的异常，并且利用Javadoc的@throws标记，标准地记录下每个异常被抛出的条件"></a>总是要单独地声明被检查的异常，并且利用Javadoc的@throws标记，标准地记录下每个异常被抛出的条件</h5><h5 id="使用Javadoc的-throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中"><a href="#使用Javadoc的-throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中" class="headerlink" title="使用Javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中"></a>使用Javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中</h5><h5 id="如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的"><a href="#如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的" class="headerlink" title="如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的"></a>如果一个类中的许多方法出于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的</h5><h4 id="45-在细节消息中包含失败-捕获消息"><a href="#45-在细节消息中包含失败-捕获消息" class="headerlink" title="45.在细节消息中包含失败-捕获消息"></a>45.在细节消息中包含失败-捕获消息</h4><h5 id="为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值"><a href="#为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值" class="headerlink" title="为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值"></a>为了捕获失败，一个异常的字符串表示应该包含所有“对该异常有贡献”的参数和域的值</h5><h4 id="46-努力使失败保持原子性"><a href="#46-努力使失败保持原子性" class="headerlink" title="46.努力使失败保持原子性"></a>46.努力使失败保持原子性</h4><h5 id="一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”"><a href="#一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”" class="headerlink" title="一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”"></a>一般而言，一个失败的方法调用应该使对象保持“它在被调用之前的状态”</h5><h4 id="47-不要忽略异常"><a href="#47-不要忽略异常" class="headerlink" title="47.不要忽略异常"></a>47.不要忽略异常</h4><h5 id="空的catch块会使异常达不到应有的目的"><a href="#空的catch块会使异常达不到应有的目的" class="headerlink" title="空的catch块会使异常达不到应有的目的"></a>空的catch块会使异常达不到应有的目的</h5><h5 id="至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的"><a href="#至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的" class="headerlink" title="至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的"></a>至少catch块也应该包含一条说明，用来解释为什么忽略掉这个异常是适合适的</h5><h4 id="48对共享可变数据的同步访问"><a href="#48对共享可变数据的同步访问" class="headerlink" title="48对共享可变数据的同步访问"></a>48对共享可变数据的同步访问</h4><h5 id="为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的"><a href="#为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的" class="headerlink" title="为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的"></a>为了提高性能，在读或写原子数据的时候，你应该避免使用同步。这个建议是非常危险而错误的</h5><h5 id="为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的"><a href="#为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的" class="headerlink" title="为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的"></a>为了在线程之间可靠地通信，以及为了互斥访问，同步是需要的</h5><h5 id="一般情况下，双重检查模式并不能正确地工作"><a href="#一般情况下，双重检查模式并不能正确地工作" class="headerlink" title="一般情况下，双重检查模式并不能正确地工作"></a>一般情况下，双重检查模式并不能正确地工作</h5><h5 id="简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁"><a href="#简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁" class="headerlink" title="简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁"></a>简而言之，无论何时当多个线程共享可变数据的时候，每个读或者写数据的线程必须获得一把锁</h5><h4 id="49-避免过多的同步"><a href="#49-避免过多的同步" class="headerlink" title="49.避免过多的同步"></a>49.避免过多的同步</h4><h5 id="为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制"><a href="#为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制" class="headerlink" title="为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制"></a>为了避免死锁的危险，在一个被同步的方法或者代码块中，永远不要放弃对客户的控制</h5><h4 id="50-永远不要在循环的外面调用wait"><a href="#50-永远不要在循环的外面调用wait" class="headerlink" title="50.永远不要在循环的外面调用wait"></a>50.永远不要在循环的外面调用wait</h4><h5 id="总是使用wait循环模式来调用wait方法"><a href="#总是使用wait循环模式来调用wait方法" class="headerlink" title="总是使用wait循环模式来调用wait方法"></a>总是使用wait循环模式来调用wait方法</h5><h4 id="51-不要依赖于线程调度器"><a href="#51-不要依赖于线程调度器" class="headerlink" title="51.不要依赖于线程调度器"></a>51.不要依赖于线程调度器</h4><h5 id="任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的"><a href="#任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的" class="headerlink" title="任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的"></a>任何依赖于线程调度器而达到正确性或性能要求的程序，很有可能是不可移植的</h5><h5 id="线程优先级是Java平台上最不可移植的特征了"><a href="#线程优先级是Java平台上最不可移植的特征了" class="headerlink" title="线程优先级是Java平台上最不可移植的特征了"></a>线程优先级是Java平台上最不可移植的特征了</h5><h5 id="对于大多数程序员来说，Thread-yield的惟一用途是在测试期间人为地增加一个程序的并发性"><a href="#对于大多数程序员来说，Thread-yield的惟一用途是在测试期间人为地增加一个程序的并发性" class="headerlink" title="对于大多数程序员来说，Thread.yield的惟一用途是在测试期间人为地增加一个程序的并发性"></a>对于大多数程序员来说，Thread.yield的惟一用途是在测试期间人为地增加一个程序的并发性</h5><h4 id="52-线程安全性的文档化"><a href="#52-线程安全性的文档化" class="headerlink" title="52.线程安全性的文档化"></a>52.线程安全性的文档化</h4><h5 id="在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分"><a href="#在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分" class="headerlink" title="在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分"></a>在一个方法的声明中出现synchronization修饰符，这是一个实现细节，并不是实现细节，并不是导出的API的一部分</h5><h5 id="一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别"><a href="#一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别" class="headerlink" title="一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别"></a>一个类为了可破多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别</h5><h5 id="安全级别"><a href="#安全级别" class="headerlink" title="安全级别"></a>安全级别</h5><p><strong>非可变的</strong></p>
<p><strong>线程安全的</strong></p>
<p><strong>有条件的线程安全</strong></p>
<p><strong>线程兼容的</strong></p>
<p><strong>线程对立的</strong></p>
<h4 id="53-避免使用线程组"><a href="#53-避免使用线程组" class="headerlink" title="53.避免使用线程组"></a>53.避免使用线程组</h4><h5 id="线程组基本上已经过时了"><a href="#线程组基本上已经过时了" class="headerlink" title="线程组基本上已经过时了"></a>线程组基本上已经过时了</h5><h4 id="54-谨慎地实现Serialization"><a href="#54-谨慎地实现Serialization" class="headerlink" title="54.谨慎地实现Serialization"></a>54.谨慎地实现Serialization</h4><h5 id="因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低"><a href="#因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低" class="headerlink" title="因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低"></a>因为实现Serialization而付出的最大代价是，一旦一个类被发布，则“改变这个类的实现”的灵活性将大大降低</h5><h5 id="实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性"><a href="#实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性" class="headerlink" title="实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性"></a>实现Serialization的第二个代价是，它增加了错误（bug）和安全漏洞的可能性</h5><h5 id="实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了"><a href="#实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了" class="headerlink" title="实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了"></a>实现Serialization的第三个代价是，随着一个类的新版本的发行，相关的测试负担增加了</h5><h5 id="实现Serialization接口不是一个很轻松就可以做出的决定"><a href="#实现Serialization接口不是一个很轻松就可以做出的决定" class="headerlink" title="实现Serialization接口不是一个很轻松就可以做出的决定"></a>实现Serialization接口不是一个很轻松就可以做出的决定</h5><h5 id="为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它"><a href="#为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它" class="headerlink" title="为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它"></a>为了继承而设计的类应该很少实现Serialization，接口也应该很少会扩展它</h5><h5 id="对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数"><a href="#对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数" class="headerlink" title="对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数"></a>对于为继承而设计的不可序列化的类，你应该考虑提供一个无参数的构造函数</h5><h4 id="55-考虑使用自定义的序列化形式"><a href="#55-考虑使用自定义的序列化形式" class="headerlink" title="55.考虑使用自定义的序列化形式"></a>55.考虑使用自定义的序列化形式</h4><h5 id="若没有认真考虑默认序列化形式是否合适，则不要接受这种形式"><a href="#若没有认真考虑默认序列化形式是否合适，则不要接受这种形式" class="headerlink" title="若没有认真考虑默认序列化形式是否合适，则不要接受这种形式"></a>若没有认真考虑默认序列化形式是否合适，则不要接受这种形式</h5><h5 id="如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的"><a href="#如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的" class="headerlink" title="如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的"></a>如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化形式可能是合适的</h5><h5 id="即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性"><a href="#即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性" class="headerlink" title="即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性"></a>即使你确定了默认序列化形式是合适的，通常你仍然要提供一个readObject方法以保证约束关系和安全性</h5><h5 id="当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点："><a href="#当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点：" class="headerlink" title="当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点："></a>当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点：</h5><p><strong>1.它使这个类的导出API永远地束缚在该类的内部表示上</strong></p>
<p><strong>2.它要消耗过多的空间</strong></p>
<p><strong>3.它要消耗过多的时间</strong></p>
<p><strong>4.它会引起栈溢出</strong></p>
<h5 id="transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉"><a href="#transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉" class="headerlink" title="transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉"></a>transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉</h5><h5 id="如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做"><a href="#如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做" class="headerlink" title="如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做"></a>如果所有的实例域都是transient的，那么，从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这么做</h5><h5 id="在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分"><a href="#在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分" class="headerlink" title="在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分"></a>在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分</h5><h5 id="不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID-serial-version-UID"><a href="#不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID-serial-version-UID" class="headerlink" title="不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID(serial version UID)"></a>不管你选择了那种序列化形式，你都要为自己编写的每个可序列化的类声明一个显式的序列版本UID(serial version UID)</h5><h4 id="56-保护性地编写readObject方法"><a href="#56-保护性地编写readObject方法" class="headerlink" title="56.保护性地编写readObject方法"></a>56.保护性地编写readObject方法</h4><h5 id="当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的"><a href="#当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的" class="headerlink" title="当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的"></a>当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的</h5><h4 id="57-必要时提供一个readResolve方法"><a href="#57-必要时提供一个readResolve方法" class="headerlink" title="57.必要时提供一个readResolve方法"></a>57.必要时提供一个readResolve方法</h4><h5 id="readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的"><a href="#readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的" class="headerlink" title="readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的"></a>readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其他的实例受控的（instance-controlled）类也是必需的</h5><h5 id="readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择"><a href="#readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择" class="headerlink" title="readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择"></a>readResolve方法的第二个用法是，就像在第56条中建议的那样，作为保护性的readObject方法的一种保守的替代选择</h5><h5 id="尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑"><a href="#尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑" class="headerlink" title="尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑"></a>尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑</h5><h5 id="readResolve方法的可访问性（accessibility）是非常重要的"><a href="#readResolve方法的可访问性（accessibility）是非常重要的" class="headerlink" title="readResolve方法的可访问性（accessibility）是非常重要的"></a>readResolve方法的可访问性（accessibility）是非常重要的</h5>]]></content>
  </entry>
</search>
